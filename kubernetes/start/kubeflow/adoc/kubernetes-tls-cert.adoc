// Section: Create TLS certificate for Kubernetes application

You can secure the network traffic of an application running on Kubernetes by encrypting it with a TLS (Transport Layer Security) private key and certificate.
Kubernetes provides the `certificates.k8s.io` API, which youc an use to provision TLS certificates signed by a Certificate Authority (CA) that you control.

Generate a TLS certificate and private key for your application with the steps detailed here.

[NOTE]
====
Perform these steps from your terminal with the `kubectl` command and access to your Kubernetes cluster.
====

=== Create a certificate signing request (CSR)

. Gather internal Kubernetes cluster information.
+
[source, console]
----
# run the dnsutils image as dnstest
kubectl run \
  dnstest \
  --image=registry.k8s.io/e2e-test-images/jessie-dnsutils:1.3 \
  -- \
  sleep infinite

# wait for dnstest to be ready
kubectl wait --for=condition=Ready pod dnstest

# export the cluster name to a variable
export K8S_CLUSTER_NAME=$( kubectl exec -i -t dnstest -- \
  nslookup kubernetes.default | \
  awk '/Name/ {print$2}' | \
  awk -F. '{ print$4"."$5 }' )

# display the cluster name
echo ""; echo "Cluster name is: ${K8S_CLUSTER_NAME}"

# delete the dnstest container
kubectl delete --force pod dnstest 2>/dev/null
----

. Store additional information in variables to simplify later use.
+
[source, console]
----
export APP="kubeflow"                            # app name
export APP_K8S_NAMESPACE="istio-system"          # app namespace
export APP_SERVICE_NAME="istio-ingressgateway"   # app service name
export SECRET_NAME="kubeflow-tls"                # app name for secrets
----

. Make a working directory.
+
[source, console]
----
mkdir -p /tmp/${APP}
----

. Create an application key.
+
[source, console]
----
openssl genrsa -out /tmp/${APP}/${APP}.key 2048
----

. Define the contents of a certificate signing request (CSR).
+
[source, console]
----
cat <<EOF > /tmp/${APP}/${APP}-csr.conf
[req]
default_bits = 2048
prompt = no
encrypt_key = yes
default_md = sha256
distinguished_name = kubelet_serving
req_extensions = v3_req
[ kubelet_serving ]
O = system:nodes
CN = system:node:*.${APP_K8S_NAMESPACE}.svc.${K8S_CLUSTER_NAME}
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth, clientAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = *.${APP_SERVICE_NAME}
DNS.2 = *.${APP_SERVICE_NAME}.${APP_K8S_NAMESPACE}.svc.${K8S_CLUSTER_NAME}
DNS.3 = *.${APP_K8S_NAMESPACE}
DNS.4 = ${EXTERNAL_FQDN}
IP.1 = 127.0.0.1
IP.2 = ${EXTERNAL_IP_ADDR}
EOF
----

. Generate the CSR.
+
[source, console]
----
openssl req -new -key /tmp/${APP}/${APP}.key \
        -out /tmp/${APP}/${APP}.csr \
        -config /tmp/${APP}/${APP}-csr.conf
----

. Validate the CSR.
+
[source, console]
----
openssl req -noout -text -in /tmp/${APP}/${APP}.csr
----


