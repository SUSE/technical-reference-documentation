:docinfo:
include::./common_docinfo_vars.adoc[]

// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
// General comments
// Keep in mind that this is a "getting started" guide and the
//   audience that you are trying to reach.
// Leverage ASCIIDoc features to make this document readable and usable:
//   - Text highlights (follow SUSE style guides)
//   - Admonitions (i.e., NOTE, TIP, IMPORTANT, CAUTION, WARNING)
//   - Code blocks
//   - Lists (ordered and unordered, as appropriate)
//   - Links (to other resources)
//   - Images
//     - Place image files under the ./media directory tree
//       (e.g., ./media/src/svg, ./media/src/png)
//     - Format preference: svg > png > jpg
//     - Consolidate images wherever possible
//       (i.e., don't use two images when one conveys the message)
//   - Use sections and subsections to organize and group related
//     steps.
// 
// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
// Variables & Attributes
//
// NOTES:
// 1. Update variables below and adjust docbook file accordingly.
// 2. Comment out any variables/attributes not used.
// 3. Follow the pattern to include additional variables.
//
// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// organization - do NOT modify
// -
:trd: Technical Reference Documentation
:type: Getting Started
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// document and product
// -
:title: Replicable Python Environments with JupyterLab and Podman
:subtitle: Software Development with SUSE
:productname: SLES 15 SP4
:platform1: SUSE Linux Enterprise Server 15 SP4
:platform2: SUSE Linux Enterprise Base Container Images
:otherproduct1: JupyterLab
:otherorg1: Project Jupyter
:otherproduct2: Python 3.10
:otherproduct3: Podman
:usecase: Data analytics and machine learning development
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// contributors
// specify information about authors, editors, and others here,
// then update docinfo file as appropriate
// -
:author1_firstname: Brian
:author1_surname: Fromme
:author1_jobtitle: Alliance Solutions Architect
:author1_orgname: SUSE
:author2_firstname: Terry
:author2_surname: Smith
:author2_jobtitle: Global Partner Solutions Director
:author2_orgname: SUSE
:other1_firstname: Dan
:other1_surname: Čermák
:other1_jobtitle: Software Engineer
:other1_orgname: SUSE
:other2_firstname: Darragh
:other2_surname: O'Reilly
:other2_jobtitle: Senior Cloud Engineer
:other2_orgname: SUSE

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// define any additional variables here for use within the document
// -
:opensuse: openSUSE Leap 15.4


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


= {title}: {subtitle}



== Introduction

=== Motivation

Modern software development is largely agile, open, and collaborative.

Nowhere has this been more obvious and impactful than in the domain of machine learning (ML), where the development community comes from a broad spectrum of domains and backgrounds.
This has resulted in a rapid state of continuous development, evolving a wealthy ecosystem of software that enable developers to make huge advances and push the limits of hardware to solve previously intractable problems in record time.
But rapid development can lead to dependency conflicts, where two applications or two components of the same application rely on different versions of the same library.

Today, developers have access to container technologies that help overcome this challenge.
Containers provide a convenient, lightweight way to package your application components with their dependencies while isolating these from other components and their dependencies.
Containers also enable massive scale, letting you run your applications everywhere they are needed - in the data center, in the cloud, and at the edge.


=== Scope

This document illustrates how to containerize the popular Python development platform for data analytics and machine learning, JupyterLab, with Podman and {platform2}.


=== Audience

This document is intended for data scientists, ML developers, operations teams, systems architects and others interested in learning more about container technologies.
To progress with this document, the reader should have basic Linux command line skills and some knowledge of containers.


== Overview

=== Goals

In this guide, you learn how to:

* set up https://podman.io[Podman] on https://www.suse.com/products/server/[{platform1}] ({productname}).

* specify and build a container image for a https://jupyter.org/[JupyterLab] ML development environment.

* run your container and access the ML development environment.


=== Software ecosystem

. https://www.suse.com/products/server/[{platform1}]
//
+
This guide leverages {productname} as a host operating system for building and running containers.
{productname} can be run on bare metal or in virtual machines to provide a stable, supportable Linux environment.
+
[NOTE]
====
Most of the steps outlined in this guide are directly transferable to https://www.opensuse.org/#Leap[{opensuse}].
====

. https://www.suse.com/products/base-container-images/[{platform2} (SLE BCI)]
//
+
A base container image provides basic functionality, such as a stripped-down Linux operating system.
It is onto a base container image that you layer your application components.
{platform2} are freely available, re-distributable, supported across many environments.
These images are designed to be a secure, flexible foundation for any containerized workload, including ML applications, that need to be deployed anywhere - in the data center, in the cloud, and on edge devices.
+
[TIP]
====
SUSE maintains up-to-date, ready-to-use container images at https://registry.suse.com/[registry.suse.com].
====

. https://podman.io[Podman]
//
+
Podman is a daemonless, open source tool for finding, building, managing, and running https://opencontainers.org/[Open Container Initiative] (OCI) containers on Linux systems.


. https://www.python.org/[Python]
//
+
Python has become a popular programming ecosystem for ML developers for its simplicity, elegance, extensibility, cross-platform availability, and active, open source community of developers and users.
With Python, ML developers have access to a vast collection of libraries, frameworks, and toolkits with which to build solutions to complex problems.


. https://jupyter.org/[JupyterLab] from Project Jupyter
//
+
JupyterLab is a modular, interactive development environment with a Web interface that enables data scientists and developers to create and share computational documents, called notebooks.
+
image::jupyterlab_ui_001.png[JupyterLab UI, scaledwidth="75%", align="center"]
+
[TIP]
====
See https://documentation.suse.com/trd/linux/single-html/gs_sles_jupyter-jupyterlab/[Replicable Python Environments with JupyterLab and SUSE Linux Enterprise Server] for more details about working with Python and JupyterLab on SUSE Linux Enterprise Server.
====


== Enabling Podman

Podman, which is short for Pod Manager, is a daemonless, open source tool for finding, building, managing, and running https://opencontainers.org/[Open Container Initiative] (OCI) containers on Linux systems.
Podman is similar to other container engines, such as *Docker*, *CRI-O*, and *containerd*.
It relies on an OCI compliant container runtime (like _runc_, _crun_, _runv_, etc.) to interface with the operating system for creating the running containers.
This means that running Podman containers is nearly indistinguishable from running those created by other common container engines.
You can also run Podman containers as an ordinary, non-privileged user, making it easier and more secure.

[TIP]
====
See the https://documentation.suse.com/container/all/single-html/SLES-container/[SUSE Container Guide] for a deeper discussion on containers and Podman.
====


=== Install Podman

Podman is not installed by default in {productname}, but you can install it with these steps.

. Enable SUSE Containers Module.
+
[source, bash]
----
sudo SUSEConnect -p sle-module-containers/15.4/x86_64
----
+
[NOTE]
====
The Containers Module is a free add-on module for your SUSE Linux Enterprise Server system.
====

. Install Podman.
+
[source, bash]
----
sudo zypper in podman
----
+
[TIP]
====
It is a good idea to make sure your system is up-to-date with security patches and updates prior to installing new software.
You can do this with the command:
[source, bash]
----
sudo zypper up
----
====


=== Enable rootless Podman

By default, only the root user can run Podman containers.
Running rootless Podman can improve security and enable multiple, unprivileged users to run containers on the same system.
To enable rootless Podman, you must configure subordinate UIDs and GIDs.

Subordinate UIDs and GIDs are assigned in ranges to each user, and are used to map users running inside a container to users on your host system.
These subordinate UID and GID ranges are specified for each user in _/etc/subuid_ and _/etc/subgid_, respectively.


. Verify that a range is not already defined for your user.
//
+
Check the _/etc/subuid_ and _/etc/subgid_ files with:
+
[source, bash]
----
grep "${USER}" /etc/subuid /etc/subgid
----
+
If output like the following is returned, ranges are already specified and you can proceed to the next section.
+
[source, bash]
----
/etc/subuid:tux:100000:65536
/etc/subgid:tux:100000:65536
----

. You can add subUID and subGID ranges with `usermod`.
+
[source, bash]
----
sudo usermod --add-subuids 100000-165535 --add-subgids 100000-165535 ${USER}
----
+
[WARNING]
====
The subUID and subGID ranges ('100000-165535' in the command example) must be unique and non-overlapping for each user on the host.
====

. Activate the subUID and subGID ranges by restarting the host system.
+
[NOTE]
====
If you modify either _/etc/subuid_ or _/etc/subgid_, you must stop all running containers owned by the user and kill the pause process running for that user.
You can do this automatically with the command:
[source, bash]
----
podman system migrate
----
====


=== Grant read access to Zypper credentials.

Your user needs access to read the SUSE Customer Center credentials, located in _/etc/zypp/credentials.d_.

Grant read permission with:
[source, bash]
----
sudo setfacl -m u:${USER}:r /etc/zypp/credentials.d/*
----


=== Configure the container storage driver

It is important to consider where and how your containers and container images are stored.
By default, Podman stores container data in _/var/lib/containers/storage_.
This is defined by the 'graphroot' option in _/etc/containers/storage.conf_ and only applies to the root user.

For unprivileged users, Podman defaults to _$HOME/.local/share/containers/storage_.
You can change this default location, say to another volume dedicated to container data.
This is done system-wide by specifying the location with the 'rootless_storage_path' setting in  the '[storage]' section of _/etc/containters/storage.conf_.
This can be overridden for a particular user by setting 'rootless_storage_path' in _$HOME/.config/containers/storage.conf_.


Another important storage container setting determines how data are written.
This is determined by the storage driver and is defined with the 'driver' setting in the '[storage]' section of _/etc/containers/storage.conf_.
For the root user, valid drivers include 'overlay', 'vfs', 'zfs', and 'btrfs'.

[NOTE]
====
The 'btrfs' driver is the default for {productname}, as https://en.wikipedia.org/wiki/Btrfs[Btrfs] is the default file system for system volumes.
Btrfs offers many advantages over earlier file systems, such as copy-on-write, pooling, snapshots, and checksums.
====

If your home directory is in a partition formatted with a different file system, Podman will default to the 'overlay' or 'vfs' driver and warn you to set an appropriate storage driver.
Usually this will be the 'overlay' driver.
You can set this without administrator help by creating or editing the file _$HOME/.config/containers/storage.conf_ with the following contents:

[listing]
----
[storage]
driver = "overlay"
----

[TIP]
====
See the manual page for containers-storage.conf for more storage settings:
`man containers-storage.conf 5`
====


== Create your application container image

You build an application container image by adding the application with the libraries and the other software it needs to run (its dependencies) as layers on top of a https://documentation.suse.com/container/all/single-html/SLES-container/#cha-bci[base container image].
In this section, you create a container image for the JupyterLab Python development environment along with some useful Python packages for machine learning and data analysis.


=== Make a build directory

You need a place in your file system to contain the files you will use for building your container image.
Your build directory can be located anywhere you have write access, such as a directory under your home directory.

Create your build directory and change to it.

For example,

[source, bash]
----
mkdir $HOME/jupcontainer
cd $HOME/jupcontainer
----



=== Define the Python environment

Replicability is critical in science and engineering.
Complex applications, like an ML model, can produce wildly different results or not work at all because of minor code variations in a library dependency.
So, it becomes important when building such applications to explicitly define all the software dependencies and their versions.

Fortunately, it is quite easy to create https://documentation.suse.com/trd/linux/single-html/gs_sles_jupyter-jupyterlab/[replicable Python environments].
Keys to this process are the `pip` Python package management tool and a file that specifies the required packages and their versions, typically named _requirements.txt_.

[NOTE]
====
Each package you specify may have several dependencies of its own.
Depending on your needs, your _requirements.txt_ file can become quite long.
If you do not specify a package version, the `pip` dependency resolver will automatically attempt install the latest version that is compatible with the other dependencies.
====

Create this _requirements.txt_ file in your build directory:

[listing]
----
jupyterlab==3.5.1
matplotlib==3.6.2
numpy==1.23.5
pandas==1.5.2
scikit-learn==1.2.0
scipy==1.9.3
seaborn==0.12.1
----

In this example, you specify the exact version of each package.
If the specified version of a package is no longer available, your container image build will fail.
You can overcome this is by removing the version specification (for example, just specify `seaborn` instead of `seaborn==0.11.2`).
This frees the `pip` dependency resolver to substitute in an appropriate, available version of the package.
After you verify functionality, you can update your _requirements.txt_ file with the new version.

[TIP]
====
You can automatically create a _requirements.txt_ file from an installed environment by issuing `pip freeze > requirements.txt`.
This will include all installed packages, except `pip` itself and its dependencies.
====


=== Define the container image

You define your application container image by providing the instructions to add the components of your application onto a base image.
These build instructions are provided in a https://github.com/containers/common/blob/main/docs/Containerfile.5.md[Containerfile].
If you are familiar with the Docker container ecosystem, a Containerfile shares the same format and most of the same options as a Dockerfile.
After defining your application container in a Containerfile, you use another tool to execute the instructions and build the image.


Create a file, named _Containerfile_, in your build directory with the following contents:

[source, Dockerfile]
----
# JupyterLab Containerfile

# https://registry.suse.com/
# build faster using SLE container image with Python already installed
FROM registry.suse.com/bci/python:latest

# create unprivileged user to run JupyterLab
RUN useradd -m jupyter
USER jupyter

# define and create notebook directory
ENV NOTEBOOKS="/home/jupyter/notebooks"
RUN mkdir -p $NOTEBOOKS

# update unprivileged user's PATH
ENV PATH="/home/jupyter/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# set working directory for subsequent commands
WORKDIR /home/jupyter

# copy requirements file into working directory
COPY requirements.txt .

# install JuypterLab
RUN set -eux pipefail; \
    pip install --upgrade pip; \
    pip install -r requirements.txt; \
    pip cache purge;

# expose JupyterLab web port
EXPOSE 8888/tcp 

# launch JupyterLab
CMD jupyter-lab --ip=* --port=8888 --no-browser --notebook-dir=$NOTEBOOKS
----


The instructions used in this _Containerfile_ to automate the build of your container are:

* `CMD` provides a default command to be executed when running the container.

* `COPY` copies files into the container.

* `EXPOSE` informs the container engine that the container listens on the specified network ports.

* `ENV` sets an environment variable.

* `FROM` specifies which base image to use.

* `RUN` executes a command in a shell (`/bin/sh -c`).

* `WORKDIR` sets the working directory for subsequent `RUN`, `CMD`, `COPY` and other instructions.


An important consideration for your container build is the base image.
You can obtain container images from a variety of sources, including the https://registry.suse.com/[SUSE container registry].

SUSE Linux Enterprise base container images are tested, certified, and enterprise-ready with up-to-date security patches.
For this guide, you use the 'latest' SLE BCI Python container image, which, at the time of this writing, is built on {productname} and features {otherproduct2}.

When choosing a base container image, keep in mind the following considerations:

Security::
Is the image from and signed by a trusted source, verifiable, and up-to-date with vulnerability fixes?

Reliability::
Is the image based on an operating system with a reputation for reliability and has the image undergone quality assurance testing?

Integration::
Are you able to use the image with your preferred software, tooling, and workflows?

Redistribution::
Are you legally able to redistribute the custom application container images you build on it?

Learn more about https://documentation.suse.com/container/all/html/SLES-container/cha-bci.html[why SUSE Linux Enterprise base container images] offer the ideal foundation for your application containers.


=== Build the container image

At this point, you have:

* a _Containerfile_ to specify how to build the container

* a _requirements.txt_ file to specify the Python packages you want

Now, you need to build your container image.
In this guide, you will use the `podman build` command to build your application container image.

[NOTE]
====
Another popular tool that facilitates the building of OCI compliant container images is https://buildah.io/[Buildah].
====


. Make sure you are in your build directory.

. Build the container image.
+
[source, bash]
----
podman build --tag jupyter .
----
+
[TIP]
====
By using the `--tag jupyter` or `-t jupyter` option, your container image will be named _localhost/jupyter_.
====

. Verify your container image exists.
+
[source, bash]
----
podman image list
----
The output of this command looks something like:
+
[source, bash]
----
REPOSITORY                      TAG         IMAGE ID      CREATED         SIZE
localhost/jupyter               latest      d8bbefc6be69  2 minutes ago   837 MB
registry.suse.com/bci/python    latest      35ebb6a7981e  11 minutes ago  125 MB
----
You should see your container image, _localhost/jupyter_.
+
[TIP]
====
You can also list images with the command `podman images`.
Learn more about Podman commands at https://docs.podman.io/en/latest/Commands.html.
====


== Run your application container

Containers are a key technology for modern software development, featuring microservices architectures.
This involves software applications that are composed of many small, independent services that communicate over well-defined application programming interfaces (APIs).
JupyterLab is not a microservice, so it may seem to be an unusual application to put into a container.
However, containerizing JupyterLab with required libraries to execute a particular Jupyter notebook can be a useful way to share a fully replicable experiment.

In this section, you see how to run and access your container.


. Prepare a shared workspace.

.. Create and enter your working directory.
+
[source, bash]
----
mkdir $HOME/mynotebooks
cd $HOME/mynotebooks
----

.. Add one or more files (such as Jupyter notebooks) to your working directory.
//
+
If you do not have your own Jupyter notebook to use, you can find a plethora to download from the Web, 
including Alexis Cook's https://www.kaggle.com/code/alexisbcook/titanic-tutorial/notebook[Titanic Tutorial] for https://kaggle.com/[Kaggle].


. Launch your JupyterLab container.
+
[source, bash]
----
podman run \
 --userns=keep-id \
 --name jupyter \
 --publish 8888:8888 \
 --volume $(pwd):/home/jupyter/notebooks \
 localhost/jupyter
----
+
====
With this command, you specify the following options:

* `--userns=keep-id` to map the user account to the same UID within the container.
* `--name` to set a name for the container.

* `--publish` or `-p` to publish a container's network port or range of ports to the host.

* `--volume` or `-v` to create a bind mount of a directory on your host to one in your container.
====
+
[NOTE]
====
If SELinux is enabled on your host system, Podman can help you properly label the mounted volume by adding either of two suffixes (`:z` or `:Z`) to the volume.
See the https://docs.podman.io/en/latest/markdown/podman-run.1.html[podman-run documentation].
====
+
[TIP]
====
Consider creating a shell script to simplify launching your container with this command.
====

. Note the output in your terminal, where you will see the URL and access token for the containerized JupyterLab environment.
+
[source, bash]
----
    To access the server, open this file in a browser:
        file:///tux/.local/share/jupyter/runtime/jpserver-1-open.html
    Or copy and paste one of these URLs:
        http://95038cde3755:8888/lab?token=77810fba9aec755d0a289a38cf2152bc3e1bf9b927082f30
     or http://127.0.0.1:8888/lab?token=77810fba9aec755d0a289a38cf2152bc3e1bf9b927082f30
----

. Access JupyterLab.
//
+
Open the Web browser on your host system to the last URL shown in your terminal (the one that begins with 'http://127.0.0.1').
If all went well, you are presented with the main JupyterLab user interface (UI).
+
image::jupyterlab-podman-ui.png[JupyterLab UI, scaledwidth="85%", align="center"]

. Verify you can access an existing file.
//
+
Your shared files are listed in the left pane of the UI.
Double-click a file name to open the file in a tab in the main pane.
+
image::jupyterlab-podman-titanic.png[JupyterLab Titanic notebook example, scaledwidth="85%", align="center"]

. Verify you can create a new notebook.

.. In the JupyterLab UI __Launcher__ tab, click __Python 3__ under __Notebook__.

.. Add some content to the new notebook.
+
image::jupyterlab-podman-notebook.png[JupyterLab notebook example, scaledwidth="85%", align="center"]
+
[TIP]
====
See the  https://jupyter-notebook.readthedocs.io/en/latest/notebook.html[Jupyter notebooks user documentation] to learn about cell types, computational kernels, basic usage, and more.
====
+
[NOTE]
====
Notebooks default to _untitled.ipynb_.
You can rename your notebook with __File__ > __Rename Notebook__ or by right-clicking the file in the file listing and selecting __Rename__.
====

.. Verify file ownership.
//
+
On your host computer, open a terminal, change to your working directory, and list the contents.
+
[source, bash]
----
ls -l
----
This produces output similar to the following:
+
[source, bash]
----
total 328
-rw-r--r-- 1 tux  users   1586 Nov  9 15:44 test1.ipynb
-rw-r--r-- 1 tux  users 328257 Nov  9 15:32 titanic-machine-learning.ipynb
----
+
where you should see your user and group associated with the new Jupyter notebook.

. Shut down JupyterLab.

.. Save and close any open Jupyter notebooks.

.. Select __File__ > __Shutdown__ in the JupyterLab UI.
//
+
Then, confirm that you want to shut down JupyterLab.
//
+
In the terminal you used to launch your container, you will see messages from JupyterLab that it is shutting down before you are returned to the command prompt.
+
[TIP]
====
You can also quickly shut down JupyterLab and exit your container by issuing CTRL-C in the terminal where you started it.
====

[NOTE]
====
Exiting a container does not delete the container.
It still exists and can be stopped and restarted again and again.
//
To see all containers on your system (including the stopped ones), use `podman container list --all`.
====


== Manage your containers

In this guide, you used `podman build` to create a container image and `podman run` to instantiate the image as a container.
Podman provides many https://docs.podman.io/en/latest/Commands.html[commands] to help you manage your containers and container images.

Explore Podman commands in https://documentation.suse.com/sle-micro/5.3/html/SLE-Micro-all/article-podman.html#sec-working-containers[Podman Guide: Working with containers].


== Summary

Modern application development eschews closed, monolithic structures in favor of open, interoperable, microservices architectures designed and implemented with containers.
Container technologies support Modern Agile software development. They enable operations teams to manage the full lifecycle of complex application landscapes across a broad spectrum of infrastructure and services - in the data center, in the cloud, and at the edge.
Innovation across many domains, including machine learning, have been accelerated by the availability of container technologies that make it easier to collaborate, test, and deploy new capabilities.

//

In this guide, you took first steps working with containers.
You learned how to install Podman, then use it to build, deploy, and manage an application container.
You also learned how to use SUSE Linux Enterprise base container images, which provide a reliable, secure, supportable, and freely redistributable base layer for your containers.




// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
// Do not modify below this break.
// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

++++
<?pdfpagebreak?>
++++


:leveloffset: 0

== Legal notice
include::common_trd_legal_notice.adoc[]

++++
<?pdfpagebreak?>
++++


:leveloffset: 0
include::common_gfdl1.2_i.adoc[]

//end
