:docinfo:
include::./common_docinfo_vars.adoc[]

// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
// General comments
// Keep in mind that this is a "getting started" guide and the
//   audience that you are trying to reach.
// Leverage ASCIIDoc features to make this document readable and usable:
//   - Text highlights (follow SUSE style guides)
//   - Admonitions (i.e., NOTE, TIP, IMPORTANT, CAUTION, WARNING)
//   - Code blocks
//   - Lists (ordered and unordered, as appropriate)
//   - Links (to other resources)
//   - Images
//     - Place image files under the ./media directory tree
//       (e.g., ./media/src/svg, ./media/src/png)
//     - Format preference: svg > png > jpg
//     - Consolidate images wherever possible
//       (i.e., don't use two images when one conveys the message)
//   - Use sections and subsections to organize and group related
//     steps.
// 
// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
// Variables & Attributes
//
// NOTES:
// 1. Update variables below and adjust docbook file accordingly.
// 2. Comment out any variables/attributes not used.
// 3. Follow the pattern to include additional variables.
//
// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// organization - do NOT modify
// -
:trd: Technical Reference Documentation
:type: Getting Started
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// document and product
// -
:title: Replicable Python Environments with JupyterLab and Podman
:subtitle: Software Development with SUSE
:productname: SLES 15 SP4
:platform1: SUSE Linux Enterprise Server 15 SP4
:platform2: SUSE Linux Enterprise Base Container Images
:productname2: SLE BCI
:python_ver: 3.10
:podman_ver: 3.4.7
:usecase: Data analytics and machine learning development
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// contributors
// specify information about authors, editors, and others here,
// then update docinfo file as appropriate
// -
:author1_firstname: Brian
:author1_surname: Fromme
:author1_jobtitle: Alliance Solutions Architect
:author1_orgname: SUSE
:author2_firstname: Terry
:author2_surname: Smith
:author2_jobtitle: Global Partner Solutions Director
:author2_orgname: SUSE
:other1_firstname: Dan
:other1_surname: Čermák
:other1_jobtitle: Software Engineer
:other1_orgname: SUSE
:other2_firstname: Victor
:other2_surname: Gregorio
:other2_jobtitle: Senior Manager, Solution Architects
:other2_orgname: SUSE
:other3_firstname: Darragh
:other3_surname: O'Reilly
:other3_jobtitle: Senior Cloud Engineer
:other3_orgname: SUSE

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// define any additional variables here for use within the document
// -
:opensuse: openSUSE Leap 15.4


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


= {title}: {subtitle}



== Introduction

=== Motivation

Modern software development is largely agile, open, and collaborative.

Nowhere has this been more obvious and impactful than in the domain of machine learning (ML), where the development community comes from a broad spectrum of domains and backgrounds.
This has resulted in a rapid state of continuous development, evolving a wealthy ecosystem of software that enable developers to make huge advances and push the limits of hardware to solve previously intractable problems in record time.
But rapid development can lead to dependency conflicts, where two applications or two components of the same application rely on different versions of the same library.

Today, developers have access to container technologies that help overcome this challenge.
Containers provide a convenient, lightweight way to package your application components with their dependencies while isolating these from other components and their dependencies.
Containers also enable massive scale, letting you run your applications everywhere they are needed - in the data center, in the cloud, and at the edge.


=== Scope

This document illustrates how to containerize the popular Python development platform for data analytics and machine learning, JupyterLab, with Podman and {platform2}.


=== Audience

This document is intended for data scientists, ML developers, operations teams, systems architects and others interested in learning more about container technologies.
To progress with this document, the reader should have basic Linux command line skills and some knowledge of containers.


=== Acknowledgements

The authors wish to thank the following individuals for their contributions to this guide:

* {other1_firstname} {other1_surname}, {other1_jobtitle}, {other1_orgname}
* {other2_firstname} {other2_surname}, {other2_jobtitle}, {other2_orgname}
* {other3_firstname} {other3_surname}, {other3_jobtitle}, {other3_orgname}



== Overview


Modern software development agile, featuring microservices architectures.
Software applications are no longer monolithic executables.
Instead, they are composed of many small, independent services that communicate over well-defined application programming interfaces (APIs).
And containers are a key technology for implementing microservices architectures.

https://jupyter.org/[JupyterLab] is an interactive development environment that is popular among machine learning, data science, and other researchers and developers.
It is not built on a microservices architecture, so it may seem to be an unusual application to put into a container.
However, containerizing JupyterLab with all required libraries can be a useful way to share a fully replicable experiment with other researchers.


=== Goals

In this guide, you learn how to:

* set up https://podman.io[Podman] on https://www.suse.com/products/server/[{platform1}] ({productname}) to run containers as a non-privileged user.

* define and build a container image for a https://jupyter.org/[JupyterLab] ML development environment.

* run your JupyterLab container with access to files on your host system.


=== Software ecosystem

. https://www.suse.com/products/server/[{platform1}]
//
+
This guide leverages {productname} as a host operating system for building and running containers.
{productname} can be run on bare metal or in virtual machines to provide a stable, supportable Linux environment.
+
[NOTE]
====
Most of the steps outlined in this guide are directly transferable to https://www.opensuse.org/#Leap[{opensuse}].
====

. https://www.suse.com/products/base-container-images/[{platform2} (SLE BCI)]
//
+
A base container image provides basic functionality, such as a stripped-down Linux operating system.
It is onto a base container image that you layer your application components.
{platform2} are freely available, re-distributable, supported across many environments.
These images are designed to be a secure, flexible foundation for any containerized workload, including ML applications, that need to be deployed anywhere - in the data center, in the cloud, and on edge devices.
+
[TIP]
====
SUSE maintains up-to-date, ready-to-use container images at https://registry.suse.com/[registry.suse.com].
====

. https://podman.io[Podman]
//
+
Podman is a daemonless, open source tool for finding, building, managing, and running https://opencontainers.org/[Open Container Initiative] (OCI) containers on Linux systems.
//
+
This guide uses Podman {podman_ver}.


. https://www.python.org/[Python]
//
+
Python has become a popular programming ecosystem for ML developers for its simplicity, elegance, extensibility, cross-platform availability, and active, open source community of developers and users.
With Python, ML developers have access to a vast collection of libraries, frameworks, and toolkits with which to build solutions to complex problems.
//
+
This guide uses Python {python_ver}.


. https://jupyter.org/[JupyterLab] from Project Jupyter
//
+
JupyterLab is a modular, interactive development environment with a Web interface that enables data scientists and developers to create and share computational documents, called notebooks.
+
image::jupyterlab_ui_001.png[JupyterLab UI, scaledwidth="75%", align="center"]
+
[TIP]
====
See https://documentation.suse.com/trd/linux/single-html/gs_sles_jupyter-jupyterlab/[Replicable Python Environments with JupyterLab and SUSE Linux Enterprise Server] for more details about working with Python and JupyterLab on SUSE Linux Enterprise Server.
====


== Enabling Podman

Podman, which is short for Pod Manager, is a daemonless, open source tool for finding, building, managing, and running https://opencontainers.org/[Open Container Initiative] (OCI) containers on Linux systems.
Podman is similar to other container engines, such as *Docker*, *CRI-O*, and *containerd*.
It relies on an OCI compliant container runtime (like _runc_, _crun_, _runv_, etc.) to interface with the operating system for creating the running containers.
This means that running Podman containers is nearly indistinguishable from running those created by other common container engines.
You can also run Podman containers as an ordinary, non-privileged user, making it easier and more secure.

[TIP]
====
See the https://documentation.suse.com/container/all/single-html/SLES-container/[SUSE Container Guide] for a deeper discussion on containers and Podman with {productname}.
====


=== Install Podman

Podman is not installed by default in {productname}, but you can install it with these steps.

. Enable SUSE Containers Module.
+
[source, bash]
----
sudo SUSEConnect -p sle-module-containers/15.4/x86_64
----
+
[NOTE]
====
The Containers Module is a free add-on module for your SUSE Linux Enterprise Server system.
====

. Install Podman.
+
[source, bash]
----
sudo zypper in podman
----
+
[TIP]
====
It is a good idea to make sure your system is up-to-date with security patches and updates prior to installing new software.
You can do this with the command:
[source, bash]
----
sudo zypper up
----
====



=== Define subordinate UIDs and GIDs

By default, only the root user can run Podman containers.
Running rootless Podman can improve security and enable multiple, unprivileged users to run containers on the same system.
To enable rootless Podman, you must configure subordinate UIDs and GIDs.

Subordinate UIDs and GIDs are assigned in ranges to each user, and are used to map users running inside a container to users on your host system.
These subordinate UID and GID ranges are specified for each user in _/etc/subuid_ and _/etc/subgid_, respectively.


. Verify that a range is not already defined for your user.
//
+
Check the _/etc/subuid_ and _/etc/subgid_ files with:
+
[source, bash]
----
grep "${USER}" /etc/subuid /etc/subgid
----
+
If output like the following is returned, ranges are already specified and you can proceed to the next section.
+
[source, bash]
----
/etc/subuid:tux:100000:65536
/etc/subgid:tux:100000:65536
----

. You can add subUID and subGID ranges with `usermod`.
+
[source, bash]
----
sudo usermod --add-subuids 100000-165535 --add-subgids 100000-165535 ${USER}
----
+
[WARNING]
====
The subUID and subGID ranges ('100000-165535' in the command example) must be unique and non-overlapping for each user on the host.
====

. Activate the subUID and subGID ranges by restarting the host system.
+
[NOTE]
====
If you modify either _/etc/subuid_ or _/etc/subgid_, you must stop all running containers owned by the user and kill the pause process running for that user.
You can do this automatically with the command:
[source, bash]
----
podman system migrate
----
====


=== Configure the container storage driver

It is important to consider where and how your containers and container images are stored.
By default, Podman stores container data in _/var/lib/containers/storage_.
This is defined by the 'graphroot' option in _/etc/containers/storage.conf_ and only applies to the root user.

For unprivileged users, Podman defaults to _$HOME/.local/share/containers/storage_.
You can change this default location, say to another volume dedicated to container data.
This is done system-wide by specifying the location with the 'rootless_storage_path' setting in  the '[storage]' section of _/etc/containters/storage.conf_.
This can be overridden for a particular user by setting 'rootless_storage_path' in _$HOME/.config/containers/storage.conf_.


Another important storage container setting determines how data are written.
This is determined by the storage driver and is defined with the 'driver' setting in the '[storage]' section of _/etc/containers/storage.conf_.
For the root user, valid drivers include 'overlay', 'vfs', 'zfs', and 'btrfs'.

[NOTE]
====
The 'btrfs' driver is the default for {productname}, as https://en.wikipedia.org/wiki/Btrfs[Btrfs] is the default file system for system volumes.
Btrfs offers many advantages over earlier file systems, such as copy-on-write, pooling, snapshots, and checksums.
====

If your home directory is in a partition formatted with a different file system, Podman will default to the 'overlay' or 'vfs' driver and warn you to set an appropriate storage driver.
Usually this will be the 'overlay' driver.
You can set this without administrator help by creating or editing the file _$HOME/.config/containers/storage.conf_ with the following contents:

[listing]
----
[storage]
driver = "overlay"
----

[TIP]
====
See the manual page for containers-storage.conf for more storage settings:
`man containers-storage.conf 5`
====


=== Grant access to your SUSE Customer Center credentials

[NOTE]
====
This section is optional.
====

An application container image starts with a base image.
Onto this, you layer additional contents, such as libraries and applications.
One way to do this is by installing software RPM packages from the {productname} repositories.
This requires your user account to have read access to your SUSE Customer Center (SCC) credentials.

For this guide, you use the latest {productname2} Python container image as your base.
This container image already includes the development and runtime components for Python {python_ver}, saving you from having to install them.
All other required software and libraries can be installed from the https://pypi.org/[Python Package Index].
Thus, you do not need to grant your user access to your SCC credentials.

[NOTE]
====
When building your container, you may see a warning of an "error mounting subscriptions."
This is because _/etc/SUSEConnect_ and _/etc/zypp/credentials.d/SCCcredentials_ are specified as default mounts in _/etc/containers/mounts.conf_.
====

If you do wish to be able to install official RPM packages from the {productname} repositories, you can grant read permission to your current user with:

[source, bash]
----
sudo setfacl -m u:${USER}:r /etc/zypp/credentials.d/*
----



== Creating container images

You build an application container image by adding the application with the libraries and the other software it needs to run (its dependencies) as layers on top of a https://documentation.suse.com/container/all/single-html/SLES-container/#cha-bci[base container image].
In this section, you create a container image for the JupyterLab Python development environment along with some useful Python packages for machine learning and data analysis.


=== Make a build directory

You need a place in your file system to contain the files you will use for building your container image.
Your build directory can be located anywhere you have write access, such as a directory under your home directory.

Create your build directory and change to it.

For example,

[source, bash]
----
mkdir $HOME/jupcontainer
cd $HOME/jupcontainer
----


=== Define the Python environment

Replicability is critical in science and engineering.
Complex applications, like an ML model, can produce wildly different results or not work at all because of minor code variations in a library dependency.
Thus, it can be critical when building such applications to explicitly define all the software dependencies and their versions.

Fortunately, it is quite easy to create https://documentation.suse.com/trd/linux/single-html/gs_sles_jupyter-jupyterlab/[replicable Python environments].
Keys to this process are the `pip` Python package management tool, the https://pypi.org/[Python Package Index], and a list of required Python packages, usually in a file named _requirements.txt_.

Your _requirements.txt_ file is a simple list of the required package names and versions.
Each package you specify may have several dependencies of its own.
Depending on your requirements, you may need to explicitly list all of these and their versions.
As a result, your _requirements.txt_ file can become quite long and detailed.
In many cases, however, you can limit your _requirements.txt_ file to just the major packages and their desired versions.
The `pip` dependency resolver will automatically attempt install the latest compatible versions of dependencies.


Create this _requirements.txt_ file in your build directory:

[listing]
----
jupyterlab==3.5.1
matplotlib==3.6.2
numpy==1.23.5
pandas==1.5.2
scikit-learn==1.2.0
scipy==1.9.3
seaborn==0.12.1
----

In this example, you specify only the major packages and their preferred versions.
If the specified version of a package is no longer available, your container image build will fail.
You can overcome this is by removing the version specification (for example, just specify `seaborn` instead of `seaborn==0.12.1`).
This frees the `pip` dependency resolver to substitute in an appropriate, available version of the package.

[WARNING]
====
Unexpected behaviors can arise due to code changes in major packages or any of their dependencies.
====


[TIP]
====
Once you have verified a functioning configuration, you can automatically generate an updated _requirements.txt_ file.
Within the environment, issue `pip freeze > requirements.txt`.
This will include all installed packages, except `pip` itself and its dependencies.
====


=== Define the container image

You define your application container image by providing the instructions to add the components of your application onto a base image.
These build instructions are provided in a https://github.com/containers/common/blob/main/docs/Containerfile.5.md[Containerfile].
If you are familiar with the Docker container ecosystem, a Containerfile shares the same format and most of the same options as a Dockerfile.
After defining your application container in a Containerfile, you use another tool to execute the instructions and build the image.

An important consideration for your container build is the base image.
You can obtain container images from a variety of sources, including the https://registry.suse.com/[SUSE container registry].

SUSE Linux Enterprise base container images are tested, certified, and enterprise-ready with up-to-date security patches.
For this guide, you use the 'latest' {productname2} Python container image, which, at the time of this writing, is built on {productname} and features Python {python_ver}.

When choosing a base container image, keep in mind the following considerations:

Security::
Is the image from and signed by a trusted source, verifiable, and up-to-date with vulnerability fixes?

Reliability::
Is the image based on an operating system with a reputation for reliability and has the image undergone quality assurance testing?

Integration::
Are you able to use the image with your preferred software, tooling, and workflows?

Redistribution::
Are you legally able to redistribute the custom application container images you build on it?

Learn https://documentation.suse.com/container/all/html/SLES-container/cha-bci.html[why SUSE Linux Enterprise base container images] offer the ideal foundation for your application containers.

//


. Change to your build directory.
+
[source, bash]
----
cd $HOME/jupcontainer
----

. Create your file, named _Containerfile_, with the following contents:
+
[source, Dockerfile]
----
# jupyterlab Containerfile

# https://registry.suse.com/
FROM registry.suse.com/bci/python:latest

# create unprivileged user
RUN useradd --uid 1000 --user-group --create-home jupyter
USER jupyter

# set notebooks directory
ENV NOTEBOOKS="/home/jupyter/notebooks"
RUN mkdir -p $NOTEBOOKS

# update the user's path to find the jupyter-lab executable
ENV PATH="/home/jupyter/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# set working directory for subsequent commands
WORKDIR /home/jupyter

# copy requirements file into working directory
COPY requirements.txt .

# install JuypterLab
RUN set -eux pipefail; \
    pip install --upgrade pip; \
    pip install -r requirements.txt; \
    pip cache purge;

# expose JupyterLab web port
EXPOSE 8888/tcp 

# change to notebooks directory
RUN cd $NOTEBOOKS

# change to notebooks directory and launch JupyterLab
CMD cd $NOTEBOOKS; jupyter-lab --ip=* --port=8888 --no-browser --notebook-dir=$NOTEBOOKS

----

Instructions used in this _Containerfile_ to automate the build of your container include:

FROM:: Specify the base image to use.

RUN:: Run a command.

ENV:: Set an environment variable, whose value is passed to subsequent commands, like `RUN` and `CMD`.

WORKDIR:: Set the working directory for subsequent `RUN`, `CMD`, `COPY` and other instructions.

COPY:: Copy files into the container.

EXPOSE:: Inform the container engine that the container listens on the specified network ports at runtime.

CMD:: Provide a default command to be executed when the container is run.



=== Build the container image

At this point, you have:

* a _Containerfile_ to specify how to build the container

* a _requirements.txt_ file to specify the Python packages you want

You can now build your application container image.
To do this you use the `podman build` command.

[NOTE]
====
Another popular tool that facilitates building OCI compliant container images is https://buildah.io/[Buildah].
====


. Make sure you are in your build directory.
+
[source, bash]
----
cd $HOME/jupcontainer
----

. Build the container image.
+
[source, bash]
----
podman build --tag jupyter .
----
+
[TIP]
====
By using the `--tag jupyter` or `-t jupyter` option, your container image will be named _localhost/jupyter_.
====

. Verify your container image exists.
+
[source, bash]
----
podman image list
----
The output of this command looks something like:
+
[source, bash]
----
REPOSITORY                      TAG         IMAGE ID      CREATED         SIZE
localhost/jupyter               latest      d8bbefc6be69  2 minutes ago   837 MB
registry.suse.com/bci/python    latest      35ebb6a7981e  11 minutes ago  125 MB
----
You should see your container image, _localhost/jupyter_.
+
[TIP]
====
You can also list images with the command `podman images`.
Learn more about Podman commands at https://docs.podman.io/en/latest/Commands.html.
====


== Running containers

=== Create a launch script

Now that you have a container image, you can use the `podman run` command to instantiate it as a container.
You must also pass a few options so Podman can enable:

* access to the JupyterLab Web interface (listening on TCP network port 8888) from your local system.

* read and write files on your local file system.

Entering a long command each time you want to launch your container can be tedious and error-prone.
In this section, you simplify this with a shell script.

. Change to your build directory to create your launch script.
+
[source, bash]
----
cd $HOME/jupcontainer
----
+
[TIP]
====
After you get things working, you may find it convenient to move your launch script into a directory in your PATH, such as _$HOME/bin_.
====

. Create the text file _juplaunch_ with this content.
+
[source, bash]
----
#!/bin/bash

# define some variables
container_name=jupyter
container_uid=1000
container_gid=1000
container_port=8888
host_port=8888
container_volume=/home/jupyter/notebooks
host_volume=$(pwd)

# launch container with options
podman run \
  --uidmap $container_uid:0:1 \
  --uidmap 0:1:$container_uid \
  --gidmap $container_gid:0:1 \
  --gidmap 0:1:$container_gid \
  --name $container_name \
  --publish $host_port:$container_port \
  --volume $host_volume:$container_volume:z \
  localhost/$container_name
----

. Grant yourself execute permissions for the script.
+
[source, bash]
----
chmod u+x juplaunch
----

In the _juplaunch_ script you pass the following options to `podman run`:

--name:: Assign a name to the container.

--publish:: Publish the container's exposed network port or range of ports to the host, making it accessible.

--volume:: Create a binding to mount the specified volume from the host into to container.
+
[NOTE]
====
The `:z` or `:Z` option is required when using a host system with SELinux to ensure proper labels are placed on volume content.

Use `:z` to tell Podman to relabel file objects so two or more containers are able to share the content.

Use `:Z` to tell Podman to relabel file objects so that only the current container can use the volume.
====

--uidmap / --gidmap:: Map the UID and GID, respectively, from the user namespace inside the container to your user namespace outside the container.
This allows you to avoid permission and ownership issues when accessing files in mounted volumes.
User namespace mappings can be complex, as rootless (unprivileged) UIDs and GIDs are mapped through intermediary subUIDs and subGIDs.
See the https://docs.podman.io/en/v3.4.4/markdown/podman-run.1.html[Podman run documentation] for a more detailed discussion.
+
[NOTE]
====
With the release of https://docs.podman.io/en/v4.3/markdown/podman-run.1.html[Podman 4.3.0], user namespace mapping is simplified with the `--userns=keep-id` option.
====


=== Launch the container


. Prepare your workspace.
//
+
Your workspace is where you will save your Jupyter notebooks.
This is just a directory on your local system that you will access with JupyterLab from within the application container.
//
+
For example,

.. Create and enter a directory to hold your notebooks.
+
[source, bash]
----
mkdir $HOME/mynotebooks
cd $HOME/mynotebooks
----

.. Add one or more files (such as Jupyter notebooks) to your working directory.
//
+
If you do not have your own Jupyter notebook to use, you can find a plethora to download from the Web, 
including Alexis Cook's https://www.kaggle.com/code/alexisbcook/titanic-tutorial/notebook[Titanic Tutorial] for https://kaggle.com/[Kaggle].


. Call your launch script.
+
[source, bash]
----
$HOME/jupcontainer/juplaunch
----

. Once you have launched your container, note the output in your terminal.
There you can find the URL with embedded access token for the containerized JupyterLab environment.
+
[source, bash]
----
    To access the server, open this file in a browser:
        file:///tux/.local/share/jupyter/runtime/jpserver-1-open.html
    Or copy and paste one of these URLs:
        http://95038cde3755:8888/lab?token=77810fba9aec755d0a289a38cf2152bc3e1bf9b927082f30
     or http://127.0.0.1:8888/lab?token=77810fba9aec755d0a289a38cf2152bc3e1bf9b927082f30
----

. Access JupyterLab.
//
+
Open the Web browser on your host system to the last URL shown in your terminal (the one that begins with 'http://127.0.0.1').
If all goes well, you are presented with the main JupyterLab user interface (UI).
+
image::jupyterlab-podman-ui.png[JupyterLab UI, scaledwidth="85%", align="center"]

. List your running containers.
//
+
Open another terminal and enter the command:
+
[source, bash]
----
podman container list
----
This produces output like:
+
[source, bash]
----
CONTAINER ID  IMAGE                     COMMAND               CREATED         STATUS             PORTS                   NAMES
95038cde3755  localhost/jupyter:latest  /bin/sh -c cd $NO...  10 seconds ago  Up 10 seconds ago  0.0.0.0:8888->8888/tcp  jupyter
----

. Verify you can access an existing file.
//
+
Your shared files are listed in the left pane of the UI.
Double-click a file name to open the file in a tab in the main pane.
+
image::jupyterlab-podman-titanic.png[JupyterLab Titanic notebook example, scaledwidth="85%", align="center"]

. Verify you can create a new notebook.

.. In the JupyterLab UI __Launcher__ tab, click __Python 3__ under __Notebook__.

.. Add some content to the new notebook.
//
+
See the  https://jupyter-notebook.readthedocs.io/en/latest/notebook.html[Jupyter notebooks user documentation] to learn about cell types, computational kernels, basic usage, and more.
+
image::jupyterlab-podman-notebook.png[JupyterLab notebook example, scaledwidth="85%", align="center"]
+
[TIP]
====
Notebooks default to _untitled.ipynb_.
You can rename your notebook with __File__ > __Rename Notebook__ or by right-clicking the file in the file listing and selecting __Rename__.
====

.. Verify file ownership.
//
+
On your host computer, open a terminal, change to your working directory, and list the contents.
+
[source, bash]
----
ls -l
----
This produces output similar to the following:
+
[source, bash]
----
total 328
-rw-r--r-- 1 tux  users   1586 Nov  9 15:44 test1.ipynb
-rw-r--r-- 1 tux  users 328257 Nov  9 15:32 titanic-machine-learning.ipynb
----
+
where you should see your user and group associated with the new Jupyter notebook.

. Shut down JupyterLab.

.. Save and close any open Jupyter notebooks.

.. Select __File__ > __Shutdown__ in the JupyterLab UI.
//
+
Then, confirm that you want to shut down JupyterLab.
//
+
In the terminal you used to launch your container, you will see messages from JupyterLab that it is shutting down before you are returned to the command prompt of your local system.


=== Restart the container
 
In the previous section, you shut down the JupyterLab server, which caused the container to also shut down.
This did not delete the container.
It still exists, and you can start and stop it again and again.

. Identify your stopped container.
+
[source, bash]
----
podman container list --all
----
+
[source, bash]
----
CONTAINER ID  IMAGE                     COMMAND               CREATED         STATUS                    PORTS                   NAMES
95038cde3755  localhost/jupyter:latest  /bin/sh -c cd $NO...  19 minutes ago  Exited (0) 8 minutes ago  0.0.0.0:8888->8888/tcp  jupyter
----
Notice the 'Exited' status.

. Start your container.
+
[source, bash]
----
podman start 95038cde3755
----
+
[TIP]
====
You do not need to specify the full container ID here.
Instead, you could specify the container name ('jupyter') or the first few unique digits of the container ID.
====
+
At this point, your container is started, but you may not have the URL with the token to access the JupyterLab server.

. Obtain the URL with access token for JupyterLab running in your container.

.. Enter a bash shell inside your container.
+
[source, bash]
----
podman exec -it 95038cde3755 /bin/bash
----

.. Display any running JupyterLab servers.
+
[source, bash]
----
jupyter-server list
----
Resulting in output like the following:
+
[source, bash]
----
[JupyterServerListApp] Currently running servers:
[JupyterServerListApp] http://localhost:8888/?token=889b9af1f0c76fb9cda24c3327b3d723a928a8298af1dd22 :: /home/jupyter/notebooks
----
+
[NOTE]
====
In starting the container, you only launched a single instance of JupyterLab.
However, it is possible to have multiple, simultaneous JupyterLab instances running on a system.
Each would be listed here with its access URL and notebook directory.
====

.. Once you have the URL, you can return to your local command line.
+
[source, bash]
----
exit
----

. Access JupyterLab by opening your Web browser to the URL you obtained.

. Log out of the JupyterLab session by selecting __File__ > __Log Out__.
//
+
[NOTE]
====
By using the __Log Out__ option, the JupyterLab server and your container continue to run.
====

. Access JupyterLab by opening your Web browser to the same URL you used in the previous step.

. This time, shut down JupyterLab by selecting __File__ > __Shutdown__.



=== Clean up

You may find that you no longer need some of your containers or container images.
Podman provides commands to help you clean up your container environment.

In this section, you delete a stopped container and then delete the image from which it was instantiated.

[TIP]
====
You can unceremoniously stop a running container with `podman stop CONTAINER-ID`.
====


. Delete your container.

.. Identify the container you wish to delete.
+
[source, bash]
----
podman container list --all
----
+
[source, bash]
----
CONTAINER ID  IMAGE                     COMMAND               CREATED      STATUS                     PORTS                   NAMES
95038cde3755  localhost/jupyter:latest  /bin/sh -c cd $NO...  4 hours ago  Exited (0) 23 minutes ago  0.0.0.0:8888->8888/tcp  jupyter
----

.. Remove the selected container.
+
[source, bash]
----
podman container rm 95038cde3755
----

. Delete an application container image.

.. Identify the container image you want to delete.
+
[source, bash]
----
podman image list
----
+
[source, bash]
----
REPOSITORY                      TAG         IMAGE ID      CREATED         SIZE
localhost/jupyter               latest      d8bbefc6be69  2 minutes ago   837 MB
registry.suse.com/bci/python    latest      35ebb6a7981e  11 minutes ago  125 MB
----

.. Remove the selected container image.
+
[source, bash]
----
podman image rm d8bbefc6be69
----
+
[source, bash]
----
Deleted: d8bbefc6be69e61120bad0449e227dda02097a41cfce3cd019dca5f427a7cd9d
Deleted: ce0883c81e5160373abf23e7ebb3c760130981cd587a52dd7cddda1af5a097bb
Deleted: c7de32119cd1a574bb5ad8172bcd94295322875a1a1cefc1e4ea3cb112fe5082
Deleted: fe38a6f6a6f22899da836dabdd4e590176ce9a8f7fa218bafec8cc5d6ed2615f
Deleted: 93aa38c86937ff21f60d36464cd7a19cadd3e6a3929a7d774b3654cf9340cbdd
Deleted: 4e55ce66ad92c43e5f790021f65b29dfa14dbb230b5838d7b83bc86b26bbe8c0
Deleted: ccce1f01ac19afae8d46cdac27fe734ef39ffd736b8d03e92524912d93c5e0c1
Deleted: 13850ddeaac18d17b52569d6f65b9c0bcd585f1259f037e7a1e090c512bfb67a
Deleted: 9c808de46ef1ff01a2e7cb90fbdc2a60157748f8052379fd896c0cdbdf57da00
Deleted: 9837e4f38101da542ed17059a09c666ee07245a7831aeb34f79dbfa774acc4d5
Deleted: a00eadade3fe2bfd4f6f42905691c143b2826fb120913d7b6cd087b773550a77
----
+
[NOTE]
====
Recall that container images are built of layers.
The additional deletions represent "parent" images not used by another image.

The base container image, 'registry.suse.com/bci/python' is not deleted.

If you would like to list all images, use `podman image list --all`.
====


Podman provides many https://docs.podman.io/en/latest/Commands.html[commands] to help you manage your containers and container images.
Some Podman commands also have synonyms that can save you a few keystrokes (for example, `podman rmi IMAGE-ID` is the same as `podman image rm IMAGE-ID`).


== Sharing

Now that you have an application container image and you have verified that it works, you may want to share it with your team, fellow researchers, or others for whom it may be of value.
A few of the options available to you are outlined here.

. Share the source.
//
+
An easy method is to simply share the files you used to create your container image.
These are small text files that you could share via email, file share service, Git repository, and so on.
Once the files are received, the recipient can follow the same steps you used to create the contaner image and run the container.

. Use `podman image save` and `podman image load`.
//
+
https://docs.podman.io/en/latest/markdown/podman-save.1.html[podman image save] allows you to save your container image and its parent layers to a tar archive that you can share.
The recipient of the tar archive can load the image with https://docs.podman.io/en/latest/markdown/podman-load.1.html[podman image load] and create containers from it.

.. Export your container image to a tar archive.
+
[source, bash]
----
podman image save --output jupyter.tar localhost/jupyter:latest
----
+
[source, bash]
----
Copying blob d555e1b0b42f done  
Copying blob fee5cefcf4f2 done  
Copying blob c20cfe968665 done  
Copying blob 9fe0f3109612 done  
Copying blob 85cf7f4629b6 done  
Copying blob e66fef9acae6 done  
Copying blob 5f70bf18a086 done  
Copying config 9952705ff5 done  
Writing manifest to image destination
Storing signatures
----

.. Send the archive to the recipient.
+
[TIP]
====
You can compress the archive file.
====

.. The recipient can load the image and launch a container with it.
+
[source, bash]
----
podman image load --input jupyter.tar
----
+
[source, bash]
----
Getting image source signatures
Copying blob e66fef9acae6 done  
Copying blob 85cf7f4629b6 done  
Copying blob fee5cefcf4f2 done  
Copying blob 9fe0f3109612 done  
Copying blob c20cfe968665 done  
Copying blob d555e1b0b42f done  
Copying blob 5f70bf18a086 done  
Copying config 9952705ff5 done  
Writing manifest to image destination
Storing signatures
Loaded image: localhost/jupyter:latest
----
+
[TIP]
====
It is a good idea to share your launch script or, at least, some guidance on the options the recipient will need to pass to `podman run`.
====




== Summary

Modern application development eschews closed, monolithic structures in favor of open, interoperable, microservices architectures designed and implemented with containers.
Podman and other container technologies, like https://www.suse.com/c/rancher_blog/what-is-kubernetes/[Kubernetes], support modern Agile software development.
They enable operations teams to manage the full lifecycle of complex application landscapes across a broad spectrum of infrastructure and services - in the data center, in the cloud, and at the edge.
Innovation across many domains, including machine learning, have been accelerated by the availability of container technologies that make it easier to collaborate, test, and deploy new capabilities.


In this guide, you took first steps working with containers.
You learned how to install Podman, then use it to build, deploy, and manage an application container.
You also learned how to use SUSE Linux Enterprise base container images, which provide a reliable, secure, supportable, and freely redistributable base layer for your containers.




// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
// Do not modify below this break.
// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

++++
<?pdfpagebreak?>
++++


:leveloffset: 0

== Legal notice
include::common_trd_legal_notice.adoc[]

++++
<?pdfpagebreak?>
++++


:leveloffset: 0
include::common_gfdl1.2_i.adoc[]

//end
