:docinfo:
include::./common_docinfo_vars.adoc[]

// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
// Variables & Attributes
// Follow indicated patterns.
//   E.g., "Ondat data plane with SUSE Rancher"
//         "Grace Hopper, Engineer, US Navy"
//         "SUSE Linux Enterprise Server 15 SP4"
//         "SUSE Rancher 2.6"
// NOTE: Some variables & attributes have been deprecated and
//       have been commented out below.
// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

:title: JupyterLab with Podman and SUSE Linux Enterprise Base Container Images: Getting Started
:productname: SUSE Linux Enterprise Server 15 SP4
:opensuse: openSUSE Leap 15.4
:defaultpython: Python 3.10
:partnerprod1: JupyterLab
:author1: Brian Fromme, Alliance Solution Architect, SUSE
:author2: Terry Smith, Partner Solutions Director, SUSE

= {title}



== Introduction

=== Motivation

Modern software development is largely agile, open, and collaborative.

Nowhere has this been more obvious and impactful than in the domain of machine learning (ML), where the development community comes from a broad spectrum of domains and backgrounds.
This has resulted in a rapid state of continuous development, evolving a wealthy ecosystem of software that enable developers to make amazing advances and push the limits of hardware to solve previously intractable problems in record time.
But rapid development can lead to dependency conflicts, where two applications or even two components of the same application rely on different versions of the same library.

Today, developers have access to container technologies that help overcome this challenge.
Containers provide a convenient, lightweight way to package your application components with their dependencies while isolating these from other components and their dependencies.
Containers also enable massive scale, letting you run your applications everywhere they are needed - in the data center, in the cloud, and even at the edge.


=== Scope

This document illustrates how to take the your first steps with containers to support ML development and implementation.


=== Audience

This document is intended for data scientists, ML developers, operations teams, systems architects and others interested in learning more about container technologies.
To progress with this document, the reader should have basic Linux command line skills and some knowledge of containers.


== Overview

=== Goals

In this guide, you learn how to:

* set up https://podman.io[Podman] on https://www.suse.com/products/server/[{productname}].

* specify and build a container image for a https://jupyter.org/[JupyterLab] ML development environment.

* run your container and access the ML development environment.


=== Software ecosystem

. https://www.suse.com/products/server/[{productname}]
//
+
This guide leverages {productname} (SLE) as a host operating system for building and running containers.
SLE can be run on bare metal or in virtual machines to provide a stable, supportable Linux environment.
+
[NOTE]
====
Most of the steps outlined in this guide are directly transferable to https://www.opensuse.org/#Leap[{opensuse}].
====

. https://www.suse.com/products/base-container-images/[SUSE Linux Enterprise Base Container Images (SLE BCI)]
//
+
A base container image provides basic functionality, such as a stripped-down Linux operating system.
It is onto a base container image that you layer your application components.
SUSE base container images are freely available, re-distributable, supported across many different environments.
These images are designed to be a secure, flexible foundation for any containerized workload, including ML applications, that need to be deployed anywhere - in the data center, in the cloud, and even on edge devices.
+
[TIP]
====
SUSE maintains up-to-date, ready-to-use container images at https://registry.suse.com/[registry.suse.com].
====

. https://podman.io[Podman]
//
+
Podman, which is short for Pod Manager, is a daemonless, open source tool for finding, building, managing, and running https://opencontainers.org/[Open Container Initiative] (OCI) containers on Linux systems.
Podman is similar to other container engines (such as Docker, CRI-O, and containerd) and relies on an OCI compliant container runtime (like runc, crun, runv, and so on) to interface with the operating system for creating the running containers.
This means that running Podman containers is nearly indistinguishable from running those created by other common container engines.
You can also run Podman containers as an ordinary, non-privileged user, making it easier and more secure.
See the https://documentation.suse.com/container/all/single-html/SLES-container/[SUSE Container Guide] for a deeper discussion on containers and Podman.


. https://www.python.org/[Python]
//
+
Python has become a popular programming ecosystem for ML developers for its simplicity, elegance, extensibility, cross-platform availability, and active, open source community of developers and users.
With Python, ML developers have access to a vast collection of libraries, frameworks, and toolkits with which to build solutions to complex problems.


. https://jupyter.org/[JupyterLab]
//
+
JupyterLab is a modular, interactive development environment with a Web interface that enables data scientists and developers to create and share computational documents, called notebooks.
+
image::jupyterlab_ui_001.png[JupyterLab UI, scaledwidth="50%", align="center"]
+
[TIP]
====
See https://documentation.suse.com/trd/linux/single-html/gs_sles_jupyter-jupyterlab/[Replicable Python Environments with JupyterLab and SUSE Linux Enterprise Server] for more details about working with Python and JupyterLab on SUSE Linux Enterprise Server.
====


== Enable Podman

Podman is not installed by default in {productname}.
So, your first step is to install it.


=== Install Podman

. Enable SUSE Containers Module.
+
[source, bash]
----
sudo SUSEConnect -p sle-module-containers/15.4/x86_64
----
+
[NOTE]
====
The Containers Module is a free add-on module for your SUSE Linux Enterprise Server system.
====

. Install Podman.
+
[source, bash]
----
sudo zypper in podman
----
+
[TIP]
====
It is a good idea to make sure your system is up-to-date with security patches and updates prior to installing new software.
You can do this with the command:
[source, bash]
----
sudo zypper up
----
====


=== Configure Podman to run without root privileges

Podman can be run as an ordinary user, but you may need to make a few configuration changes.
To keep this simple, you will grant your current user, `$USER`, this access.

. Define subUID and subGID ranges for your current user.
//
+
You need to define a range of UIDs and GIDs that will be allocated to users inside the container and mapped onto the host.
You can check the `/etc/subuid` and `/etc/subgid` files to see if these ranges are already defined for your user.
//
+
If they are not, issue the command:
+
[source, bash]
----
sudo usermod --add-subuids 100000-165535 --add-subgids 100000-165535 ${USER}
----
+
[WARNING]
====
The subUID and subGID ranges ('100000-165535' in the command example) must not overlap for different users and not reuse UIDs and GIDs of existing users on the host.
====

. Ensure your current user has permissions to access zypper credentials on the host.
The container may need access to read the SUSE Customer Center credentials, located in `/etc/zypp/credentials.d`.
//
+
Grant permission to the user with:
+
[source, bash]
----
sudo setfacl -m u:${USER}:r /etc/zypp/credentials.d/*
----


=== Verify the container storage driver

It is important to consider where and how your containers and container images are stored.
System container storage settings are defined in `/etc/containers/storage.conf`.
Storage settings can be overridden for a particular user by options placed in `$HOME/.config/containers/storage.conf` or with appropriate environment variables.

The default location Podman uses for container data is `/var/lib/containers/storage`.
This is defined by the 'graphroot' option in `/etc/containers/storage.conf` and only applies to the root user.

For ordinary users, Podman defaults to `$HOME/.local/share/containers/storage`.
It can be useful to change this location, such as when user home directories are remotely mounted NFS shares.
This behavior can be changed for all users by setting 'rootless_storage_path' in the '[storage]' section of `/etc/containers/storage.conf`.

How container data are written is determined by the storage driver.
This is defined by the 'driver' setting in the '[storage]' section of `/etc/containers/storage.conf`.
For the root user, valid drivers include 'overlay2', 'vfs', 'zfs', and 'btrfs'.

[NOTE]
====
The 'btrfs' driver is the default for {productname}, since https://en.wikipedia.org/wiki/Btrfs[Btrfs] is the default filesystem for system volumes.
Btrfs offers many advantages over earlier filesystems, such as copy-on-write, pooling, snapshots, and checksums.
====

If your home directory is in a partition formatted with a different filesystem, Podman will default to the 'overlay2' or 'vfs' driver and warn you to set an appropriate storage driver.
In most cases, this will be the 'overlay2' driver.
You can set this without administrator help by creating the file `$HOME/.config/container/storage.conf` with the following content:

[listing]
----
[storage]
driver = "overlay2"
----

[TIP]
====
See the manual page for containers-storage.conf for more storage settings:
`man containers-storage.conf 5`
====


== Build the container image

// Add the following sections with better titles:
// === Create a build directory
// === Create requirements.txt
// === Create entrypoint.sh script
// === Create Containerfile
// === Use podman to build the container image


An application container image is built by adding the application with the libraries and the other software it needs to run (its dependencies) as layers on top of a base container image.
In this section, you create a container image for the JupyterLab Python development environment along with some useful Python packages.


=== Create a build directory

You need a working directory to contain the files you need for building your container.

. Make a build directory.
+
[source, bash]
----
mkdir jupcontainer
----

. Change to the build directory.
+
[source, bash]
----
cd jupcontainer
----


=== Create the `requirements.txt` file

Replicability is critical in science and engineering.
Complex applications, like an ML model, can produce wildly different results or not work at all due to minor code variations in a library dependency.
So, it becomes important when building such applications to explicitly define all the software dependencies and their versions

Fortunately, it is quite easy to create https://documentation.suse.com/trd/linux/single-html/gs_sles_jupyter-jupyterlab/[replicable Python environments].
Key to this process are the `pip` Python package management tool and a file that lists the required packages and their versions, typically named `requirements.txt`.

[NOTE]
====
Each package you specify may have several dependencies of its own.
Depending on your needs, your `requirements.txt` file can become quite long.
However, in practice, you only need to specify the main packages used for your application, and the `pip` dependency resolver will automatically install the right dependencies to enable your application.
====

Create a `requirements.txt` in your build directory with the contents shown below:

[listing]
----
matplotlib==3.3.4
numpy==1.19.5
pandas==1.1.5
scikit-learn==0.24.2
scipy==1.5.4
tensorflow==2.6.2
jupyterlab==3.2.9
----


[TIP]
====
You can automatically create a `requirements.txt` file from an installed environment by issuing `pip freeze > requirements.txt`.
This will include all installed packages, except `pip` itself and its dependencies.
To install the specified packages, use `pip install -r requirements.txt`.
====


=== Create user ID mapping

// Briefly explain why user ID mapping is required (to ensure container user and host user have permissions to access the same files)

Podman allows a container to run in unprivileged (rootless) mode run in the user namespace.
By default, containers run with a UID/GID that is chosen for you.
That means that your user, plus its associated file access, and your container's user are going to be different.
This can cause friction in your development and is something you may want to resolve.

The simplest way to resolve different user IDs is to create a method for user ID mapping.
This method will pass the user ID you want your container to run as to the _podman run_ command.
The user ID mapping is handled by a shell script, which will be listed below.

The following script will be referred to as an _entrypoint_ script, because it uses the ENTRYPOINT Containerfile feature.

Create an `entrypoint.sh` script.
//

[listing]
----
#!/bin/bash

# DEBUG: optional debug verbosity
[[ $DEBUG -eq 1 ]] && set -x

# add container user, passed LOCAL_USERID required
CONT_UID=${LOCAL_USERID:?}
CONT_UNAME=jupyterlab
CONT_HOME=/home/${CONT_UNAME}
VIRTENV=/home/virtenv

echo "Starting with UID : $CONT_UID"
groupadd mail
useradd -s /bin/bash -u $CONT_UID -d $CONT_HOME -m $CONT_UNAME

# useradd will not apply skel files if the container homedir is created
# via a container engine's --mount flag, so force the copy of these files.
cp -ar /etc/skel/. ${CONT_HOME}/
chown -R $CONT_UID $CONT_HOME

# DEBUG: allow user to edit virtenv
[[ $DEBUG -eq 1 ]] && chown -R $CONT_UID $VIRTENV

# place container engine CMD into a script to facilitate an exec
echo "$@" > /usr/local/bin/cmd.sh
chmod +x /usr/local/bin/cmd.sh

# exec CMD as the local user 
exec su - $CONT_UNAME -c /usr/local/bin/cmd.sh
----

It is not important that you understand all the details of this script, unless it is interesting to you.
The _entrypoint.sh_ script uses an environment variable, LOCAL_USERID, to pass an user id number to the container.
As you will see in the Containerfile shown below, you then run the _entrypoint.sh_ script in your container.

=== Create Containerfile

A _Containerfile_ is a set of instructions that tell the container engine how to build your container.
If you are familiar with Docker, a Containerfile has the same format as a Dockerfile.
You can read more about Containerfiles here:

* https://docs.podman.io/en/latest/markdown/podman-build.1.html

* https://github.com/containers/common/blob/main/docs/Containerfile.5.md

Your goal here is to create a simple development tool to share your MNIST experiment in JupyterLab.
An example Containfile is shown below.

. Containerfile for JupyterLab with MNIST
+
----
# See: https://registry.suse.com/
FROM registry.suse.com/bci/bci-base:latest

ENV ZYPPERCMD="zypper --non-interactive"

RUN $ZYPPERCMD install python3 python3-pip
RUN python3 -m venv /home/virtenv

RUN . /home/virtenv/bin/activate && pip install --upgrade pip
RUN . /home/virtenv/bin/activate && pip install jupyterlab

# Expose the JupyterLab web port
EXPOSE 8888/tcp

# See: https://denibertovic.com/posts/handling-permissions-with-docker-volumes/
COPY entrypoint.sh /usr/local/bin/entrypoint.sh
RUN chmod +x /usr/local/bin/entrypoint.sh
ENTRYPOINT ["/usr/local/bin/entrypoint.sh"]
CMD [".", "/home/virtenv/bin/activate", "&&", "jupyter-lab"]
----
+
TIP:  For compatibility, Podman will also read files named Dockerfile.

The first element of the Containerfile is the FROM clause.
This instruction points to a SUSE Linux Enterprise Base Container Image (SLE BCI).

The RUN clauses will install JupyterLab in the container and the EXPOSE clause will open a TCP/IP port for the service.

You can learn more about containers in the https://documentation.suse.com/container/all/single-html/SLES-container/[SUSE Container Guide].
You might also want to read the section on https://documentation.suse.com/container/all/single-html/SLES-container/#cha-bci[SLE BCI].

=== Build the Container

Now you will build the container.
Make sure you have created the Contailerfile with the contents described above.
Then, use the podman command to build your container image.

NOTE: Use your favorite editor or _vi_ to paste the contents of Containfile.

// podman build
// $ podman build -t=ImageName -
. Build a container for your JupyerLab & MNIST example
+
[source, bash]
----
cd ~/py-keras
vi Containerfile
podman build . -t mnist
----
+
TIP: You may have to work through issues with your Containerfile to get your image built properly.


== Run the application container

The container image you have built now lives in the localhost repository and is tagged with the name _mnist_.
You can verify that your image has been created with the following podman command.

. Show the container images on your localhost
+
[source, bash]
----
podman images
----
+
TIP: Learn more about _podman_ commands at: https://docs.podman.io/en/latest/Commands.html

It is only a little more complication to run the container you just created.
That is because we want to add the MNIST code to the container and pass our User ID.
The commands listed below depend upon the Bash shell as your default.
For more information on Bash, see https://www.gnu.org/software/bash/[GNU Bash].

// TARGET=jupyterlab
// mkdir -p $TARGET
// cp -f mnist_convnet.py $TARGET
// 
// podman run \
//   --mount type=bind,source="$(pwd)/$TARGET",target=/home/$TARGET \
//   --network host \
//   --env LOCAL_USERID=$UID \
// localhost/mnist

. Run your container and pass it your User ID
+
[source, bash]
----
TARGET=jupyterlab
mkdir -p $TARGET
cp -f mnist_convnet.py $TARGET

podman run \
  --mount type=bind,source="$(pwd)/$TARGET",target=/home/$TARGET \
  --network host \
  --env LOCAL_USERID=$UID \
localhost/mnist
----
+
TIP: You could put these commands into a file, such as: _podmanrun.sh_


=== Test the Container

When _podman run_ command starts your container, you will see its output in your shell.
It will look something like this:

. Example output of the _podman run_ command
+
----
sles@sp4:~/Python/py-keras/mnist$ ./podmanrun.sh
Starting with UID : 1000
[I 2022-10-03 22:34:10.355 ServerApp] jupyterlab | extension was successfully linked.
[I 2022-10-03 22:34:10.363 ServerApp] Writing Jupyter server cookie secret to /home/jupyterlab/.local/share/jupyter/runtime/jupyter_cookie_secret
...
[I 2022-10-03 22:34:10.583 ServerApp]  or http://127.0.0.1:8888/lab?token=d6f27830445721412980dbf43004fc855aee5eee058b3c67
[I 2022-10-03 22:34:10.584 ServerApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).
[W 2022-10-03 22:34:10.587 ServerApp] No web browser found: could not locate runnable browser.
[C 2022-10-03 22:34:10.587 ServerApp]

To access the server, open this file in a browser:
file:///home/jupyterlab/.local/share/jupyter/runtime/jpserver-45-open.html
Or copy and paste one of these URLs:
http://localhost:8888/lab?token=d6f27830445721412980dbf43004fc855aee5eee058b3c67
or http://127.0.0.1:8888/lab?token=d6f27830445721412980dbf43004fc855aee5eee058b3c67
----
+
TIP:  If you see warnings, you should understand that aspect of the _podman run_ process.


At this point, you are ready to test your container.
The output shown above has an HTTP URL that you can use from your browser to interact with JupyterLab.
Copy the _localhost_ HTTP URL.
Paste that URL into your favorite browser.

You should see a JupyterLab web page, such as the one below.

image::Screenshot-JupyterLab-Container.png[JupyterLab,640,480,pdfwidth=80%,scaledwidth=80%]

TIP:  When you are done with your container, Ctrl-C in the shell will terminate the _podman run_ command.

== Summary

// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
// Summarize what was covered, including:
//   - Motivation
//   - Installation
//   - Demonstration
// Include any hints about other capabilities.
// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

Companies are transforming the way that software and services are being created.
Modern software is developed by teams that are agile, open, and collaborative.
Adding machine learning to the development process relies on collaborative tool and processes.

This guide has shown you how to create containers that are based on SUSE Linux Enterprise (SLE) Base Container Images (BCI).
BCI-based containers leverage proven, tested, and supported code from SUSE.
As such, SLE BCIs allow open, flexible, and secure development and are excellent for containerized workload and machine-learning deployments.
With SUSE Edge technologies, SLE BCIs help you to quickly deploy secure, high-quality ML applications on edge devices.

This guide showed steps to create a container of JupyterLab and code for the MNIST image analysis model.
There are other techniques to share code, that don't involve creating a container for JupyterLab.
The steps shown here are for your education and provide an interest web-based container example.

With the podman knowledge you've gained here, you are now ready to create your own BCI-based containers.



== Additional resources

// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
// Provide any additional resources that may help the reader
//   continue to explore this topic.
// Use an unordered list for references.
// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =





// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
// Do not modify below this break.
// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

++++
<?pdfpagebreak?>
++++


:leveloffset: 0

== Legal notice
include::common_trd_legal_notice.adoc[]

++++
<?pdfpagebreak?>
++++


:leveloffset: 0
include::common_gfdl1.2_i.adoc[]

//end
