:docinfo:
include::./common_docinfo_vars.adoc[]

// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
// General comments
// Keep in mind that this is a "getting started" guide and the
//   audience that you are trying to reach.
// Leverage ASCIIDoc features to make this document readable and usable:
//   - Text highlights (follow SUSE style guides)
//   - Admonitions (i.e., NOTE, TIP, IMPORTANT, CAUTION, WARNING)
//   - Code blocks
//   - Lists (ordered and unordered, as appropriate)
//   - Links (to other resources)
//   - Images
//     - Place image files under the ./media directory tree
//       (e.g., ./media/src/svg, ./media/src/png)
//     - Format preference: svg > png > jpg
//     - Consolidate images wherever possible
//       (i.e., don't use two images when one conveys the message)
//   - Use sections and subsections to organize and group related
//     steps.
// 
// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
// Variables & Attributes
//
// NOTES:
// 1. Update variables below and adjust docbook file accordingly.
// 2. Comment out any variables/attributes not used.
// 3. Follow the pattern to include additional variables.
//
// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// organization - do NOT modify
// -
:trd: Technical Reference Documentation
:type: Getting Started
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// document and product
// -
:title: JupyterLab, Python, and Containers
:subtitle: Developing with SUSE Linux Enterprise Base Container Images
:product1: SLES
:product1_full: SUSE Linux Enterprise Server
:product1_ver_base: 15
:product1_version: 15 SP5
:product1_ver: 15.5
:product1_version_min: 15 SP3
:product1_url: https://www.suse.com/products/server
:product2: SLE-BCI
:product2_full: SUSE Linux Enterprise Base Container Images
:product2_url: https://www.suse.com/products/base-container-images
:product2_registry: https://registry.suse.com
:productname: SLES 15
:platform1: SUSE Linux Enterprise Server 15
:platform2: SUSE Linux Enterprise Base Container Images
:productname2: SLE BCI
:servicepack: 5
:usecase: Data analytics and machine learning development
:executive_summary: Deploy Python and JupyterLab with SUSE Linux Enterprise base container images and Podman for development and collaboration.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// contributors
// specify information about authors, editors, and others here,
// then update docinfo file as appropriate
// -
:author1_firstname: Brian
:author1_surname: Fromme
:author1_jobtitle: Alliance Solutions Architect
:author1_orgname: SUSE
:author2_firstname: Terry
:author2_surname: Smith
:author2_jobtitle: Global Partner Solutions Director
:author2_orgname: SUSE
:other1_firstname: Dan
:other1_surname: Čermák
:other1_jobtitle: Software Engineer
:other1_orgname: SUSE
:other2_firstname: Victor
:other2_surname: Gregorio
:other2_jobtitle: Senior Manager, Solution Architects
:other2_orgname: SUSE
:other3_firstname: Darragh
:other3_surname: O'Reilly
:other3_jobtitle: Senior Cloud Engineer
:other3_orgname: SUSE

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// define any additional variables here for use within the document
// -
:containerguide_url: https://documentation.suse.com/container/all/single-html/Container-guide
:opensuse: openSUSE Leap
:opensuse_version: 15.5
:opensuse_url: https://www.opensuse.org/#Leap
:jupyter_url: https://jupyter.org/
:podman_ver: 4.4.4
:podman_url: https://podman.io/
:podman_docs: https://docs.podman.io/en/latest
:python_ver: 3.11
:python_url: https://www.python.org/
:pypi_full: Python Package Index
:pypi_url: https://pypi.org/
:rancher_url: https://rancher.com/

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


= {title}: {subtitle}



== Introduction

=== Motivation

Modern software development is largely agile, open, and collaborative.

Nowhere has this been more obvious and impactful than in the domain of machine learning (ML), where the development community comes from a broad spectrum of domains and backgrounds.
This has resulted in a rapid state of continuous development, evolving a wealthy ecosystem of software that enable developers to make huge advances and push the limits of hardware to solve previously intractable problems in record time.
But rapid development can lead to dependency conflicts, where two applications or two components of the same application rely on different versions of the same library.

Today, developers have access to container technologies that help overcome this challenge.
Containers provide a convenient, lightweight way to package your application components with their dependencies while isolating these from other components and their dependencies.
Containers also enable massive scale, letting you run your applications everywhere they are needed - in the data center, in the cloud, and at the edge.


=== Scope

This document illustrates how to containerize the popular Python development platform for data analytics and machine learning, JupyterLab, with Podman and {product2_full}.


=== Audience

This document is intended for data scientists, ML developers, operations teams, systems architects and others interested in learning more about container technologies.
To progress with this document, the reader should have basic Linux command line skills and some knowledge of containers.


=== Acknowledgements

The authors wish to thank the following individuals for their contributions to this guide:

* {other1_firstname} {other1_surname}, {other1_jobtitle}, {other1_orgname}
* {other2_firstname} {other2_surname}, {other2_jobtitle}, {other2_orgname}
* {other3_firstname} {other3_surname}, {other3_jobtitle}, {other3_orgname}



== Overview


Modern software development is agile, featuring microservices architectures.
Software applications are no longer monolithic executables.
Instead, they are composed of many small, independent services that communicate over well-defined application programming interfaces (APIs).
And containers are a key technology for implementing microservices architectures.

{jupyter_url}[JupyterLab] is an interactive development environment that is popular among machine learning, data science, and other researchers and developers.
It is not built on a microservices architecture, so it may seem to be an unusual application to put into a container.
However, containerizing JupyterLab with all required libraries can be a useful way to share a fully replicable experiment with other researchers.


=== Goals

In this guide, you learn how to:

* set up {podman_url}[Podman] on {product1_url}[{product1_full}] ({product1}) to run containers as a non-privileged user.

* define and build a container image for a {jupyter_url}[JupyterLab] ML development environment.

* run your JupyterLab container with access to files on your host system.

* share your JupyterLab container with others.


=== Software ecosystem

. {product1_url}[{product1_full}]
//
+
This guide leverages {product1_full} {product1_version} as a host operating system for building and running containers.
{product1_full} can be run on bare metal or in virtual machines to provide a stable, supportable Linux environment.
+
[NOTE]
====
The steps detailed in this guide were developed and tested on {product1_full} {product1_version_min} through {product1_version}.
Little to no modification should be required to follow this guide with newer versions of {product1_full} or corresponding versions of {opensuse_url}[{opensuse}].
====

. {product2_url}[{product2_full}] ({product2})
//
+
A base container image provides basic functionality, such as a stripped-down Linux operating system.
It is onto a base container image that you layer your application components.
{product2_full} are freely available, re-distributable, supported across many environments.
These images are designed to be a secure, flexible foundation for any containerized workload, including ML applications, that need to be deployed anywhere - in the data center, in the cloud, and on edge devices.
+
[TIP]
====
SUSE maintains up-to-date, ready-to-use container images at {product2_registry}.
====

. {podman_url}[Podman]
//
+
Podman is a daemonless, open source tool for finding, building, managing, and running https://opencontainers.org/[Open Container Initiative] (OCI) containers on Linux systems.
//
+
This guide uses Podman {podman_ver}.


. {python_url}[Python]
//
+
Python has become a popular programming ecosystem for ML developers for its simplicity, elegance, extensibility, cross-platform availability, and active, open source community of developers and users.
With Python, ML developers have access to a vast collection of libraries, frameworks, and toolkits with which to build solutions to complex problems.
//
+
This guide references Python {python_ver} but should work with minimal issues for other 3.x releases.


. {jupyter_url}[JupyterLab] from Project Jupyter
//
+
JupyterLab is a modular, interactive development environment with a Web interface that enables data scientists and developers to create and share computational documents, called notebooks.
+
image::jupyterlab_ui_001.png[JupyterLab UI, scaledwidth="75%", align="center"]
+
[TIP]
====
See https://documentation.suse.com/trd/linux/single-html/gs_sles_jupyter-jupyterlab/[Replicable Python Environments with JupyterLab and SUSE Linux Enterprise Server] for more details about working with Python and JupyterLab on SUSE Linux Enterprise Server.
====


== Enabling Podman

Podman, which is short for Pod Manager, is a daemonless, open source tool for finding, building, managing, and running https://opencontainers.org/[Open Container Initiative] (OCI) containers on Linux systems.
Podman is similar to other container engines, such as *Docker*, *CRI-O*, and *containerd*.
It relies on an OCI-compliant container runtime (like _runc_, _crun_, _runv_, etc.) to interface with the operating system for creating the running containers.
This means that running Podman containers is nearly indistinguishable from running those created by other common container engines.
You can also run Podman containers as an ordinary, non-privileged user, making it easier and more secure.

[TIP]
====
See the {containerguide_url}[SUSE Container Guide] for a deeper discussion on containers and Podman with {product1_full}.
====


=== Install Podman

Podman is not installed by default in {product1_full}, but you can install it with these steps.

. Enable SUSE Containers Module (a free add-on).
+
[source, console]
----
sudo SUSEConnect -p sle-module-containers/RELEASE_VERSION/x86_64
----
+
Replace `_RELEASE_VERSION_` with the {product1_full} release you are using.
//
+
For example: If you are using {product1_full} {product1_version}, then you would use:
+
[source, console, subs="attributes+"]
----
sudo SUSEConnect -p sle-module-containers/{product1_ver}/x86_64
----

. Install Podman.
+
[source, console]
----
sudo zypper in podman
----
+
[TIP]
====
It is a good idea to make sure your system is up-to-date with security patches and updates prior to installing new software.
You can do this with the command:

[source, console]
----
sudo zypper up
----
====



=== Define subordinate UIDs and GIDs

By default, only the root user can run Podman containers.
Running rootless Podman can improve security and enable multiple, unprivileged users to run containers on the same system.
To enable rootless Podman, you must configure subordinate UIDs and GIDs.

Subordinate UIDs and GIDs are assigned in ranges to each user, and are used to map users running inside a container to users on your host system.
These subordinate UID and GID ranges are specified for each user in `/etc/subuid` and `/etc/subgid`, respectively.


. Verify that a range is not already defined for your user.
//
+
Check the `/etc/subuid` and `/etc/subgid` files with:
+
[source, console]
----
grep "${USER}" /etc/subuid /etc/subgid
----
+
If output like the following is returned, ranges are already specified and you can proceed to the next section.
+
[source, console]
----
/etc/subuid:tux:100000:65536
/etc/subgid:tux:100000:65536
----

. You can add subUID and subGID ranges with `usermod`.
+
[source, console]
----
sudo usermod --add-subuids 100000-165535 --add-subgids 100000-165535 ${USER}
----
+
[WARNING]
====
The subUID and subGID ranges ('100000-165535' in the command example) must be unique and non-overlapping for each user on the host.
====

. Activate the subUID and subGID ranges by restarting the host system.
+
[NOTE]
====
If you modify either `/etc/subuid` or `/etc/subgid`, you must stop all running containers owned by the user and terminate the pause process running for that user.

You can do this automatically with the command:
[source, console]
----
podman system migrate
----
====


=== Configure the container storage driver

It is important to consider where and how your containers and container images are stored.
By default, Podman stores container data in `/var/lib/containers/storage`.
This is defined by the 'graphroot' option in `/etc/containers/storage.conf` and only applies to the root user.

For unprivileged users, Podman defaults to `$HOME/.local/share/containers/storage`.
You can change this default location, say to another volume dedicated to container data.
This is done system-wide by specifying the location with the 'rootless_storage_path' setting in  the '[storage]' section of `/etc/containers/storage.conf`.
This can be overridden for a particular user by setting 'rootless_storage_path' in `$HOME/.config/containers/storage.conf`.


Another important storage container setting determines how data are written.
This is determined by the storage driver and is defined with the 'driver' setting in the '[storage]' section of `/etc/containers/storage.conf`.
For the root user, valid drivers include 'overlay', 'vfs', 'zfs', and 'btrfs'.

[TIP]
====
The 'overlay' driver is a safe default choice.

If your home directory is on a different, supported file system, create or edit the file, `$HOME/.config/containers/storage.conf`, and add a '[storage]' section, such as:

[listing]
----
[storage]
driver = "btrfs"
----

====



=== Grant access to your SUSE Customer Center credentials

It is only necessary to grant your user access to your SUSE Customer Center (SCC) credentials if you intend to install RPM software packages from the official {product1_full} repositories.


In this guide, you use the latest {product2_full} Python container image as your base.
This container image already includes the official development and runtime components of a recent Python release, saving you from having to install them.
All other software and libraries required for this guide can be installed from the {pypi_url}[{pypi_full}] with the `pip` command.
Thus, you do not need to grant your user this access to follow this guide.

If you choose to use a different base image or want to use other software packages, your user may require access to your SCC credentials.
You can do this by simply granting read permission to the files in `/etc/zypp/credentials.d`:

[source, console]
----
sudo setfacl -m u:${USER}:r /etc/zypp/credentials.d/*
----

[NOTE]
====
If you do not grant access to your SCC credentials, you may see a warning of an "error mounting subscriptions" when building your container.
This is because `/etc/SUSEConnect` and `/etc/zypp/credentials.d/SCCcredentials` are specified as default mounts in `/etc/containers/mounts.conf`.
====



== Creating container images

You build an application container image by adding the application with the libraries and the other software it needs to run (its dependencies) as layers on top of a {containerguide_url}/#cha-bci[base container image].
In this section, you create a container image for the JupyterLab Python development environment along with some useful Python packages for machine learning and data analysis.


=== Make a build directory

You need a place in your file system to contain the files you will use for building your container image.
Your build directory can be located anywhere you have write access, such as a directory under your home directory.

Create your build directory and change to it.

For example:

[source, console]
----
mkdir $HOME/jupcontainer
cd $HOME/jupcontainer
----


=== Define the Python environment

Replicability is critical in science and engineering.
Complex applications, like an ML model, can produce wildly different results or not run at all because of minor code variations in a library dependency.
Thus, it can be critical when building such applications to explicitly define all the software dependencies and their versions.

Fortunately, it is quite easy to create https://documentation.suse.com/trd/linux/single-html/gs_sles_jupyter-jupyterlab/[replicable Python environments].
Keys to this process are the `pip` Python package management tool, the {pypi_url}[{pypi_full}], and a list of required Python packages, usually in a file named `requirements.txt`.

Your `requirements.txt` file is a simple list of the names and versions of required packages.
For example:

[listing]
----
matplotlib==3.6.2
numpy==1.23.5
pandas==1.5.2
----

Each package you specify may have several dependencies of its own, and you can explicitly list every package and its version in your `requirements.txt` file.
Often, though, you only need to list the major packages you want to install, and the `pip` resolver will attempt to identify and install compatible versions of the dependencies.

If you do not specify the version of a package you want, the `pip` dependency resolver will attempt to install the latest version that is compatible with the other packages.
Because of code changes in different versions, this can result in unexpected behaviors in your code.


For this guide, you can let the `pip` resolver pick the versions for you.
Create this `requirements.txt` file in your build directory:

[listing]
----
jupyterlab
matplotlib
numpy
pandas
scikit-learn
scipy
seaborn
----



[TIP]
====
When you have verified a functioning configuration, you can automatically generate an updated `requirements.txt` file.

Within the environment, issue `pip freeze > requirements.txt`.
This will include all installed packages, except `pip` itself and its dependencies.
====


=== Define the container image

Define your application container image by providing the instructions to add the components of your application onto the base image.
These instructions are provided in a https://github.com/containers/common/blob/main/docs/Containerfile.5.md[Containerfile].
If you are familiar with the Docker container ecosystem, a Containerfile shares the same format and most of the same options as a Dockerfile.
After defining your application container in a Containerfile, you use another tool to execute the instructions and build the image.

An important consideration for your container build is the base image.
You can obtain container images from a variety of sources, including the {product2_registry}[SUSE container registry].

{product2_full} are tested, certified, and enterprise-ready with up-to-date security patches.
For this guide, you use the 'latest' Python container image, which, at the time of this writing, is built on {product1_full} {product1_version} and features Python {python_ver}.

When choosing a base container image, keep in mind the following considerations:

Security::
Is the image from and signed by a trusted source, verifiable, and up to date with vulnerability fixes?

Reliability::
Is the image based on an operating system with a reputation for reliability and has the image undergone quality assurance testing?

Integration::
Are you able to use the image with your preferred software, tooling, and workflows?

Redistribution::
Are you legally able to redistribute the custom application container images you build on it?

Learn {containerguide_url}/#cha-bci[why SUSE Linux Enterprise base container images] offer the ideal foundation for your application containers.

//

Now create your Containerfile to define the container image.


. Change to your build directory.
+
[source, console]
----
cd $HOME/jupcontainer
----

. Create your file, named `Containerfile`, with the following contents:
+
[source, Dockerfile]
----
# jupyterlab Containerfile

# https://registry.suse.com/
FROM registry.suse.com/bci/python:latest

# create unprivileged user
RUN useradd --uid 1000 --user-group --create-home jupyter
USER jupyter

# set notebooks directory
ENV NOTEBOOKS="/home/jupyter/notebooks"
RUN mkdir -p $NOTEBOOKS

# update the user's path to find the jupyter-lab executable
ENV PATH="/home/jupyter/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# set working directory for subsequent commands
WORKDIR /home/jupyter

# copy requirements file into working directory and set ownership
COPY --chown=1000:1000 requirements.txt .

# install JuypterLab
RUN set -euxo pipefail; \
    pip install --upgrade pip; \
    pip install -r requirements.txt; \
    pip cache purge;

# expose JupyterLab web port
EXPOSE 8888/tcp 

# change to notebooks directory and launch JupyterLab
CMD cd $NOTEBOOKS; jupyter-lab --ip=* --port=8888 --no-browser --notebook-dir=$NOTEBOOKS

----

Instructions used in this `Containerfile` to automate the build of your container include:

FROM:: Specify the base image to use.

RUN:: Run a command.

ENV:: Set an environment variable, whose value is passed to subsequent commands, like `RUN` and `CMD`.

WORKDIR:: Set the working directory for subsequent `RUN`, `CMD`, `COPY` and other instructions.

COPY:: Copy files into the container.

EXPOSE:: Inform the container engine that the container listens on the specified network ports at runtime.

CMD:: Provide a default command to be executed when the container is run.



=== Build the container image

At this point, you have:

* `Containerfile` to specify how to build the container

* `requirements.txt` file to specify the Python packages you want

You can now build your application container image.
To do this you use the `podman build` command.

[NOTE]
====
Another popular tool that simplifies building OCI-compliant container images is https://buildah.io/[Buildah].
====


. Make sure you are in your build directory.
+
[source, console]
----
cd $HOME/jupcontainer
----

. Build the container image.
+
[source, console]
----
podman build --tag jupyter .
----
+
[TIP]
====
By using the `--tag jupyter` or `-t jupyter` option, your container image will be named `localhost/jupyter`.
====

. Verify your container image exists.
+
[source, console]
----
podman image list
----
The output of this command looks something like:
+
[source, console]
----
REPOSITORY                      TAG         IMAGE ID      CREATED         SIZE
localhost/jupyter               latest      d8bbefc6be69  2 minutes ago   837 MB
registry.suse.com/bci/python    latest      35ebb6a7981e  11 minutes ago  125 MB
----
You should see your container image with the name, 'jupyter', in your 'localhost' repository.
Your container image is also assigned a unique identifier.
The first several digits of this unique identifier is shown in the 'IMAGE ID' column.
+
[TIP]
====
You can also list images with the command `podman images`.
Learn more about Podman commands at {podman_docs}/Commands.html.
====


== Running containers

=== Create a launch script

Now that you have a container image, you can use the `podman run` command to instantiate it as a container.
You must also pass a few options so Podman can enable:

* access to the JupyterLab Web interface (listening on TCP network port 8888) from your local system.

* read and write files on your local file system.

Entering a long command each time you want to launch your container can be tedious and error-prone.
In this section, you simplify this with a shell script.

. Change to your build directory to create your launch script.
+
[source, console]
----
cd $HOME/jupcontainer
----
+
[TIP]
====
After you get things working, you may find it convenient to move your launch script into a directory in your PATH, such as `$HOME/bin`.
====

. Create the text file `juplaunch` with this content.
+
[source, console]
----
#!/bin/bash

# define some variables
container_name=jupyter
container_uid=1000
container_gid=1000
container_port=8888
host_port=8888
container_volume=/home/jupyter/notebooks
host_volume=$(pwd)

# launch container with options
podman run \
  --userns=keep-id:uid=$container_uid,gid=$container_gid \
  --name $container_name \
  --publish $host_port:$container_port \
  --volume $host_volume:$container_volume:Z \
  localhost/$container_name
----

. Grant yourself execute permissions for the script.
+
[source, bash]
----
chmod u+x juplaunch
----

In the `juplaunch` script you pass the following options to `podman run`:

--name:: Assign a name to the container.

--publish:: Publish the container's exposed network port or range of ports to the host, making it accessible.

--volume:: Create a binding to mount the specified volume from the host into to container.
+
[NOTE]
====
The `:z` or `:Z` option is required when using a host system with SELinux to ensure proper labels are placed on volume content.

Use `:z` to tell Podman to relabel file objects so two or more containers can share access to the volume and its contents.

Use `:Z` to tell Podman to relabel file objects so that only the current container can use the volume.
====

--userns:: Set the user namespace mode for the container.
With the release of Podman 4.3.0, you can use the `--userns=keep-id` option to map the UID and GID of the user inside the container to your UID and GID outside the container.
This allows you to avoid ownership and permission issues when accessing files in mounted volumes.
Further discussion of user namespace mapping can be found in the {podman_docs}/markdown/podman-run.1.html[Podman run documentation].
+
[NOTE]
====
Prior to Podman 4.3.0, user namespace mapping was approached using the `--uidmap` and `--gidmap` options.
====


=== Launch the container


. Prepare your workspace.
//
+
Your workspace is where you will save your Jupyter notebooks.
This is a directory on your local system that you will access with JupyterLab from within the application container.
//
+
For example,

.. Create and enter a directory to hold your notebooks.
+
[source, console]
----
mkdir $HOME/mynotebooks
cd $HOME/mynotebooks
----

.. Add one or more files (such as Jupyter notebooks) to your working directory.
+
[TIP]
====
If you do not have your own Jupyter notebook to use, you can find a plethora to download from the Web, including Alexis Cook's https://www.kaggle.com/code/alexisbcook/titanic-tutorial/notebook[Titanic Tutorial] for https://kaggle.com/[Kaggle].
====


. Call your launch script.
+
[source, console]
----
$HOME/jupcontainer/juplaunch
----

. After launching your container, note the output in your terminal.
There you can find the URL with embedded access token for the containerized JupyterLab environment.
+
[listing]
----
    To access the server, open this file in a browser:
        file:///tux/.local/share/jupyter/runtime/jpserver-1-open.html
    Or copy and paste one of these URLs:
        http://95038cde3755:8888/lab?token=77810fba9aec755d0a289a38cf2152bc3e1bf9b927082f30
     or http://127.0.0.1:8888/lab?token=77810fba9aec755d0a289a38cf2152bc3e1bf9b927082f30
----

. Access JupyterLab.
//
+
Open the Web browser on your host system to the last URL shown in your terminal (the one that begins with `http://127.0.0.1`).
If all goes well, you are presented with the main JupyterLab user interface (UI).
+
image::jupyterlab-podman-ui.png[JupyterLab UI, scaledwidth="85%", align="center"]

. List your running containers.
//
+
Open another terminal and enter the command:
+
[source, console]
----
podman container list
----
This produces output like:
+
[listing]
----
CONTAINER ID  IMAGE                     COMMAND               CREATED         STATUS             PORTS                   NAMES
95038cde3755  localhost/jupyter:latest  /bin/sh -c cd $NO...  10 seconds ago  Up 10 seconds ago  0.0.0.0:8888->8888/tcp  jupyter
----
+
[TIP]
====
The first column, 'CONTAINER ID', is the truncated, unique identifier of your container.
You can use this container ID with various Podman commands to manage your container.
====

. Verify you can access an existing file.
//
+
Your shared files are listed in the left pane of the UI.
Double-click a file name to open the file in a tab in the main pane.
+
image::jupyterlab-podman-titanic.png[JupyterLab Titanic notebook example, scaledwidth="85%", align="center"]

. Verify you can create a new notebook.

.. In the JupyterLab UI __Launcher__ tab, click __Python 3__ under __Notebook__.

.. Add some content to the new notebook.
//
+
See the  https://jupyter-notebook.readthedocs.io/en/latest/notebook.html[Jupyter notebooks user documentation] to learn about cell types, computational kernels, basic usage, and more.
+
image::jupyterlab-podman-notebook.png[JupyterLab notebook example, scaledwidth="85%", align="center"]
+
[TIP]
====
Notebooks default to `untitled.ipynb`.
You can rename your notebook with __File__ > __Rename Notebook__ or by right-clicking the file in the file listing and selecting __Rename__.
====

.. Verify file ownership.
//
+
On your host computer, open a terminal, change to your working directory, and list the contents.
+
[source, console]
----
ls -l
----
This produces output similar to the following:
+
[listing]
----
total 328
-rw-r--r-- 1 tux  users   1586 Nov  9 15:44 test1.ipynb
-rw-r--r-- 1 tux  users 328257 Nov  9 15:32 titanic-machine-learning.ipynb
----
+
where you should see your user and group associated with the new Jupyter notebook.

. Shut down JupyterLab.

.. Save and close any open Jupyter notebooks.

.. Select __File__ > __Shutdown__ in the JupyterLab UI.
//
+
Then, confirm that you want to shut down JupyterLab.
//
+
In the terminal you used to launch your container, you will see messages from JupyterLab that it is shutting down before you are returned to the command prompt of your local system.


=== Restart the container
 
In the previous section, you shut down the JupyterLab server, which caused the container to also shut down.
This did not delete the container.
It still exists, and you can start and stop it again and again.

[TIP]
====
You can override this behavior and automatically remove containers when they are shut down by using the `--rm` option with the `podman run` command.
====


. Identify your stopped container.
//
+
The default behavior of `podman container list` is to list only running containers, you need to use the `--all` option.
+
[source, console]
----
podman container list --all
----
+
[listing]
----
CONTAINER ID  IMAGE                     COMMAND               CREATED         STATUS                    PORTS                   NAMES
95038cde3755  localhost/jupyter:latest  /bin/sh -c cd $NO...  19 minutes ago  Exited (0) 8 minutes ago  0.0.0.0:8888->8888/tcp  jupyter
----
Notice that the STATUS of your container is 'Exited'.

. Start your container.
+
[source, console]
----
podman start CONTAINER-ID
----
Replace `CONTAINER-ID` with the ID of your container.
+
[TIP]
====
You only need to type the first few unique digits of the container ID.
Alternatively, you can refer to the container by its name ('jupyter').
====

. Verify that your container is running.
+
[source, console]
----
podman ps
----
+
[listing]
----
CONTAINER ID  IMAGE                     COMMAND               CREATED         STATUS                    PORTS                   NAMES
95038cde3755  localhost/jupyter:latest  /bin/sh -c cd $NO...  22 minutes ago  Up 2 minutes  0.0.0.0:8888->8888/tcp  jupyter
----
+
[TIP]
====
`podman ps`, `podman container ps`, `podman container list`, and `podman container ls` are synonyms for the same command.
====

. Obtain the URL for JupyterLab running in your container.

.. Enter a Bash shell inside your container.
+
[source, console]
----
podman exec -it CONTAINER-ID /bin/bash
----

.. Display any running JupyterLab servers.
+
[source, console]
----
jupyter-server list
----
Resulting in output like the following:
+
[listing]
----
[JupyterServerListApp] Currently running servers:
[JupyterServerListApp] http://localhost:8888/?token=889b9af1f0c76fb9cda24c3327b3d723a928a8298af1dd22 :: /home/jupyter/notebooks
----
+
[NOTE]
====
In starting the container, you only launched a single instance of JupyterLab.
However, it is possible to have multiple, simultaneous JupyterLab instances running on a system.
Each would be listed here with its access URL and notebook directory.
====

.. When you have copied the URL, you can return to your local command line.
+
[source, console]
----
exit
----

. Access JupyterLab by opening your Web browser to the URL you obtained.

. Log out of the JupyterLab session by selecting __File__ > __Log Out__.
//
+
[TIP]
====
By using the __Log Out__ option, the JupyterLab server and your container continue to run.
Check this with the `podman ps` command.
====

. Access JupyterLab by opening your Web browser to the same URL you used in the previous step.

. This time, shut down JupyterLab by selecting __File__ > __Shutdown__.
//
+
Verify that your container has shut down.



=== Clean up

You may find that you no longer need some of your containers or container images.
Podman provides commands to help you clean up your container environment.

In this section, you delete a stopped container and then delete the image from which it was instantiated.

[TIP]
====
You can unceremoniously stop a running container with `podman stop CONTAINER-ID`.
====


. Delete your container.

.. Identify the container you want to delete.
+
[source, console]
----
podman container list --all
----
+
[listing]
----
CONTAINER ID  IMAGE                     COMMAND               CREATED      STATUS                     PORTS                   NAMES
95038cde3755  localhost/jupyter:latest  /bin/sh -c cd $NO...  2 hours ago  Exited (0) 23 minutes ago  0.0.0.0:8888->8888/tcp  jupyter
----

.. Remove the selected container.
+
[source, console]
----
podman container rm CONTAINER-ID
----
Replace _CONTAINER-ID_ with the appropriate container ID.

. Delete an application container image.

.. Identify the container image you want to delete.
+
[source, console]
----
podman image list
----
+
[listing]
----
REPOSITORY                      TAG         IMAGE ID      CREATED         SIZE
localhost/jupyter               latest      d8bbefc6be69  2 hours ago     837 MB
registry.suse.com/bci/python    latest      35ebb6a7981e  3 hours ago     125 MB
----

.. Remove the selected container image.
+
[source, console]
----
podman image rm IMAGE-ID
----
+
Be sure to replace _IMAGE-ID_ with the appropriate container image ID.
+
[listing]
----
Deleted: d8bbefc6be69e61120bad0449e227dda02097a41cfce3cd019dca5f427a7cd9d
Deleted: ce0883c81e5160373abf23e7ebb3c760130981cd587a52dd7cddda1af5a097bb
Deleted: c7de32119cd1a574bb5ad8172bcd94295322875a1a1cefc1e4ea3cb112fe5082
Deleted: fe38a6f6a6f22899da836dabdd4e590176ce9a8f7fa218bafec8cc5d6ed2615f
Deleted: 93aa38c86937ff21f60d36464cd7a19cadd3e6a3929a7d774b3654cf9340cbdd
Deleted: 4e55ce66ad92c43e5f790021f65b29dfa14dbb230b5838d7b83bc86b26bbe8c0
Deleted: ccce1f01ac19afae8d46cdac27fe734ef39ffd736b8d03e92524912d93c5e0c1
Deleted: 13850ddeaac18d17b52569d6f65b9c0bcd585f1259f037e7a1e090c512bfb67a
Deleted: 9c808de46ef1ff01a2e7cb90fbdc2a60157748f8052379fd896c0cdbdf57da00
Deleted: 9837e4f38101da542ed17059a09c666ee07245a7831aeb34f79dbfa774acc4d5
Deleted: a00eadade3fe2bfd4f6f42905691c143b2826fb120913d7b6cd087b773550a77
----
+
--
The command output lists the image IDs of deleted container images.

Recall that container images are built of layers, and each layer is a container image.
If these "parent" container images are not used by another image, they are deleted as well.
--
+
[IMPORTANT]
====
The base container image, 'registry.suse.com/bci/python', is not deleted.
====


Podman provides many {podman_docs}/Commands.html[commands] to help you manage your containers and container images.
Some Podman commands also have synonyms that can save you a few keystrokes (for example, `podman rmi IMAGE-ID` is the same as `podman image rm IMAGE-ID`).



== Sharing

Now that you have an application container image and you have verified that it works, you can share it with your team, fellow researchers, or others for whom it may be of value.
Some sharing options are outlined here.

. Use the source.
//
+
An easy method is to simply share the source files you used to create your container image.
These are small text files that you could share via e-mail, a file share service, a Git repository, and so on.
The recipient can use the received files and follow the same steps you used to create and run the container.

. Use an image archive.
//
+
Use {podman_docs}/markdown/podman-save.1.html[podman image save] to save your container image and its parent layers to a TAR archive that you can share.
The recipient of the TAR archive can load the image with {podman_docs}/markdown/podman-load.1.html[podman image load] and run it with `podman run`.
+
[TIP]
====
Your recipient would likely appreciate receiving a copy of your launch script or, at least, some guidance on the options to pass with `podman run`.
====

.. Save your container image to a TAR archive.
+
[source, console]
----
podman image save --output jupyter.tar CONTAINER-ID
----
+
[TIP]
====
You could also refer to your container by name.

For example:
[source, console]
----
podman image save --output jupyter.tar localhost/jupyter:latest
----
====
+
[listing]
----
Copying blob d555e1b0b42f done  
Copying blob fee5cefcf4f2 done  
Copying blob c20cfe968665 done  
Copying blob 9fe0f3109612 done  
Copying blob 85cf7f4629b6 done  
Copying blob e66fef9acae6 done  
Copying blob 5f70bf18a086 done  
Copying config 9952705ff5 done  
Writing manifest to image destination
Storing signatures
----

.. Send the image archive to the recipient.
+
[TIP]
====
Image archive files can be large.
Even compressed, they may be too large to send via e-mail.
Make sure to choose a sharing method that both you and your intended recipient can use.
====

.. When you receive an image archive, use Podman to load it into your local registry.
+
[source, console]
----
podman image load --input jupyter.tar
----
+
[listing]
----
Getting image source signatures
Copying blob e66fef9acae6 done  
Copying blob 85cf7f4629b6 done  
Copying blob fee5cefcf4f2 done  
Copying blob 9fe0f3109612 done  
Copying blob c20cfe968665 done  
Copying blob d555e1b0b42f done  
Copying blob 5f70bf18a086 done  
Copying config 9952705ff5 done  
Writing manifest to image destination
Storing signatures
Loaded image: localhost/jupyter:latest
----
+
[TIP]
====
It is a good idea to share your launch script or, at least, some guidance on the options the recipient will need to pass to `podman run`.
====

. Use a container registry.
//
+
Podman provides the {podman_docs}/markdown/podman-push.1.html[podman push] command for publishing your container images to a registry and the {podman_docs}/markdown/podman-pull.1.html[podman pull] command for retrieving images from a registry.
+
====
A container registry hosts repositories for storing and accessing container images.
A container registry is often an essential component of cloud native DevOps, enabling automation in continuous integration and continuous delivery/deployment (CI/CD).
You can host your own container registry or use a container registry service.
Factors to consider when choosing a registry solution include (but are not limited to):

* Pricing: Are you able to budget operating costs for your needs today and for tomorrow?
* Content types: Do you need to store more artifacts than only a container image?
* Availability: Does the registry offer uptime and regional availability to meet your needs?
* Authentication and authorization: What identity and access management features and integrations are offered?
* Security: Are security features and controls sufficient to meet your policy and regulatory requirements?
* Rate limits: Are the allowed number of pushes and pulls per unit of time sufficient?
* Ease of migration: How difficult would it be to migrate to a different registry?

====




== Summary

Modern application development eschews closed, monolithic structures in favor of open, interoperable, microservices architectures designed and implemented with containers.
Container technologies accelerate innovation by enabling complex applications and processes to be developed, deployed, and managed across a broad spectrum of infrastructures and services - in the data center, in the cloud, and at the edge.
Fast-developing fields, like machine learning, have benefited greatly from the use of container technologies.

Modern, OCI-compliant containers are built in layers on top of a base image.
{product2_full} provides a reliable, secure, supportable, and freely redistributable base image for your application containers.
There are a variety of tools for building and managing containers.
A simple but powerful container management tool is Podman.
In this guide you used Podman to build a container image featuring JupyterLab, a Web-based Python development environment.
You then used Podman to run, manage and share your application container.




// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
// Do not modify below this break.
// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

++++
<?pdfpagebreak?>
++++


:leveloffset: 0

== Legal notice
include::common_trd_legal_notice.adoc[]

++++
<?pdfpagebreak?>
++++


:leveloffset: 0
include::common_gfdl1.2_i.adoc[]

//end
